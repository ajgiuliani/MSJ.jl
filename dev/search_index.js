var documenterSearchIndex = {"docs":
[{"location":"tutos/tutorials/#Tutorials-1","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutos/tutorials/#","page":"Tutorials","title":"Tutorials","text":"using Plots","category":"page"},{"location":"tutos/tutorials/#","page":"Tutorials","title":"Tutorials","text":"The MSj package intends to provide an access to the common open source mass spectrometry file format using Julia.","category":"page"},{"location":"man/calculations/#Properties-calculations-1","page":"Properties calculations","title":"Properties calculations","text":"","category":"section"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"From a molecular formula, it is possible to : ","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"calculate the molecular masses \ncalculate the isotopic distributions\nsimulate a mass spectrum providing and isotopic distribution and a peak width.","category":"page"},{"location":"man/calculations/#Parsing-a-chemical-formula-1","page":"Properties calculations","title":"Parsing a chemical formula","text":"","category":"section"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"The private function MSj.formula takes an input string representing a chemical formula, such as \"CH4\", counts the number of atoms in the formula and returns a dictionary. ","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"MSj.formula(\"CH3Br\")\nDict(\"Br\" => 1,\"C\" => 1,\"H\" => 3)\nDict{String,Int64} with 3 entries:\n  \"Br\" => 1\n  \"C\"  => 1\n  \"H\"  => 3","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"In the previous example, the dictionary had three elements corresponding to the three atomic species found in the \"CH3Br\" formula. The \"Br\" key has the value 1, the \"C\" key has also 1 and the \"H\" key has a value equals to 3. The output of this function will be used by all the other functions, which will calculate properties from it. The  MSj.formula function accepts stoichiometric regular molecular formulas as well as more developed forms. For hexane the following entries \"C6H14\", \"CH3CH2CH2CH2CH2CH3\" or \"CH3(CH2)4CH3\" are equivalents. ","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"MSj.formula(\"C6H14\");\nDict(\"C\" => 6,\"H\" => 14)\nMSj.formula(\"CH3CH2CH2CH2CH2CH3\");\nDict(\"C\" => 6,\"H\" => 14)\nMSj.formula(\"CH3(CH2)4CH3\");\nDict(\"C\" => 6,\"H\" => 14)","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"The indices found after a parenthesis are used to multiply the elements inside the parenthesis. If no indices are found after \")\", then the group is not multiply. The parenthesis are also used to specify an isotope, for example, consider ethane isotopically labelled with carbon 13:","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"MSj.formula(\"CH3(13C)H3\");\nDict(\"C\" => 1,\"13C\" => 1,\"H\" => 6)","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"These expressions are equivalent: \"CH3(13C)H3\", \"CH3(13CH3)\", \"C(13C)H6\". The following isotopes are recognized by MSj.formula:","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"1H   for ^1H_1 (protium)\n2H   for ^2H_2 (deuterium)\nD    is equivalent to 2H\n12C  for ^12C_6\n13C  for ^13C_6\n14N  for ^14N_7\n15N  for ^15N_7\n16O  for ^16O_8\n18O  for ^18O_8\n32S  for ^32S_16\n34S  for ^34S_16","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"The elements are stored in a dictionary called MSj.Elements. Each key of the MSj.Elements points to an Array of MSj.Isotope, which is a structure used to stored the different properties of the isotopes:","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"struct Isotope\n    m::Float64           # mass\n    f::Float64           # natural frequency\n    logf::Float64        # logarythm of the natural frequency\n    Z::Int               # atomic number\n    A::Int               # mass number\n    active::Bool         # is radioactive\nend","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"The isotopes are sorted by natural frequency. Hence, for instance, the first sulfur isotope is ^32S_16 with a natural frenquency of 0.995 followed by  ^34S_16 with 0.043, etc.","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"julia> E = MSj.Elements[\"S\"]\n4-element Array{MSj.Isotope,1}:\n MSj.Isotope(31.9720711741, 0.9498500119990401, -0.051451188958515866, 16, 32, false)\n MSj.Isotope(33.96786703, 0.04252059835213182, -3.157766653355949, 16, 34, false)\n MSj.Isotope(32.9714589101, 0.00751939844812415, -4.890269137820559, 16, 33, false)\n MSj.Isotope(35.9670812, 0.00010999120070394368, -9.115110188972029, 16, 36, false)","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"The first element of the array, is the most naturally abundant isotope. The properties of the isotopes may be accessed by:","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"julia> E = MSj.Elements[\"S\"];\njulia> E[1]                            # returns the most abundant isotope of sulfur\nMSj.Isotope(31.9720711741, 0.9498500119990401, -0.051451188958515866, 16, 32, false)\njulia> E[2].f                          # returns natural abundance of the second most abundant istotope of sulfur.\n0.04252059835213182","category":"page"},{"location":"man/calculations/#Molecular-masses-1","page":"Properties calculations","title":"Molecular masses","text":"","category":"section"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"The public function masses, return a dictionary with three keys \"Monoisotopic\", \"Average\" and \"Nominal\", defined as:","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"Mass Element Molecule or ion\nNominal Mass number of the most abundant stable isotope Sum of the nominal masses of the most abundant stable isotopes\nMonoistopic Atomic mass of the most abundant stable isotope Sum of the atomic masses of the most abundant stable isotopes\nAverage Mass average function of the relative abundances Sum of the average atomic weights of the constituents","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"The masses for hexane are calculated by:","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"julia> m = masses(\"CH3(CH2)4CH3\")\nDict(\"C\" => 6,\"H\" => 14)\nDict{String,Float64} with 3 entries:\n  \"Monoisotopic\" => 86.1096\n  \"Average\"      => 86.178\n  \"Nominal\"      => 86.0","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"And the specific masses may be accessed by:","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"julia> m[\"Average\"]\n86.178\njulia> m[\"Monoisotopic\"]\n86.10955045178\njulia> m[\"Nominal\"]\n86.0","category":"page"},{"location":"man/calculations/#Isotopic-distributions-1","page":"Properties calculations","title":"Isotopic distributions","text":"","category":"section"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"The public function isotopic_distribution calculates the isotopic distribution of the given formula. The function takes the following arguments:","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"formula: String\ntarget probability: Real number \ncharge: optional argument Int, by default = +1\ntau: optional Real number set by default to 0.1\nthe elements dictionary: set by default to MSj.Elements.","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"The calculations is based on the implementation of the isospec algorithm.  Briefly, the algorithm search for the small set of isotopologues for which the total abundance is equal to the target probability. The calculation return a vector with all the configurations found. The first column gives the masses, the second column the probabilities of the configurations, and the following columns gives the configurations, such as:","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"julia> I = isotopic_distribution(\"C6H14\", 0.9999, charge = +1)\nDict(\"C\" => 6,\"H\" => 14)\n5Ã—6 Array{Union{Float64, Int64, String},2}:\n   \"Masses\"   \"Probability\"   \"12C\"   \"13C\"    \"1H\"   \"2H\"\n 86.1096     0.935476        6       0       14      0\n 87.1129     0.0612122       5       1       14      0 \n 88.1163     0.00166891      4       2       14      0 \n 87.1158     0.00151559      6       0       13      1","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"The resulting array is intend to be readable easily, and thus the first line contains the descriptors or the columns. It may also be easily exported to a delimited file.","category":"page"},{"location":"man/calculations/#Simulated-mass-spectra-1","page":"Properties calculations","title":"Simulated mass spectra","text":"","category":"section"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"The result of an isotopic distribution calculation may be convoluted with a peak shape to produce a simulated mass spectrum. Such an operatio, is achieved by the simulate function. The function takes the following arguments:","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"the Arrayresulting from the isotopic_distribution calculation\nthe width in Dalton of the peak shape\nthe model used for the peak shape. By default it is set to model=:gauss, but may be model=:lorentz or model=:voigt.\nAn Int value for the number of points in the mass spectrum. By default set to Npoints=1000.","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"Hence, the simulated istopic distribution of haxane can be obtained and plotted like this:","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"julia> I = isotopic_distribution(\"C6H14\", 0.9999, charge = +1);\nDict(\"C\" => 6,\"H\" => 14)\njulia> sim = simulate(I, 0.05, model= :lorentz);\njulia> Using Plots\njulia> plot(sim)","category":"page"},{"location":"man/calculations/#","page":"Properties calculations","title":"Properties calculations","text":"See Plotting for more information on how to plot mass spectra.","category":"page"},{"location":"man/exporting/#Exporting-data-1","page":"Exporting data","title":"Exporting data","text":"","category":"section"},{"location":"man/exporting/#","page":"Exporting data","title":"Exporting data","text":"note: Note\nThis feature is currently under development. ","category":"page"},{"location":"tutos/jupyter/#Jupyter-notebooks-1","page":"Jupyer notebooks","title":"Jupyter notebooks","text":"","category":"section"},{"location":"tutos/jupyter/#","page":"Jupyer notebooks","title":"Jupyer notebooks","text":"Jupyter notebooks are web based documents that may contains both codes, figures and other textual elements (such as equations, links, ...).  Jupyter notebook may be installed easily using Julia:","category":"page"},{"location":"tutos/jupyter/#","page":"Jupyer notebooks","title":"Jupyer notebooks","text":"julia> using Pkg\njulia> Pkg.add(\"IJulia\")","category":"page"},{"location":"tutos/jupyter/#","page":"Jupyer notebooks","title":"Jupyer notebooks","text":"When IJulia is installed, then a notebook may be launch like this:","category":"page"},{"location":"tutos/jupyter/#","page":"Jupyer notebooks","title":"Jupyer notebooks","text":"julia> using IJulia\njulia> notebook()","category":"page"},{"location":"tutos/jupyter/#","page":"Jupyer notebooks","title":"Jupyer notebooks","text":"The notebook() function should launch a web browser from which a new notebook  may be started. On each entry of the notebook code, Markdown or text may be inserted. Each line of code may be executed and will eventually return a result. In the following, the tutorials are given in Jupyter notebook form and can be viewed using nbviewer.","category":"page"},{"location":"man/filtering/#Combining-and-filtering-data-1","page":"Combining and filtering data","title":"Combining and filtering data","text":"","category":"section"},{"location":"man/filtering/#Average-1","page":"Combining and filtering data","title":"Average","text":"","category":"section"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"The average returns the average of the mass spectra directly from a Vector{MSscan} after Importing data data or directly from the filename.","category":"page"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"julia> average(\"filename\")\nMSj.MSscans([1, 2, 3 ....\n\njulia> scans = load(\"filename\")\n51-element Array{MSj.MSscan,1}:\n MSj.MSscan(1, 0.1384, 5.08195e6, [140.083, 140.167, 140.25, 140.333, 140.417, 140.5, 140.583, 140.667, 140.75, 140.833  â€¦  1999.25, 1999.33, 1999.42, ....)\n...\n\njulia> average(scans)\nMSj.MSscans([1, 2, 3 ....\n","category":"page"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"Operating on files takes more time than working on Vector{MSscan} but may be useful to reduce the memory load.","category":"page"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"Without any argument the average function averages the entire content of the data and the chromatogram function operates on also on the entire data.","category":"page"},{"location":"man/filtering/#Filtering-1","page":"Combining and filtering data","title":"Filtering","text":"","category":"section"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"The average and chromatogram functions may takes arguments to select specific fields of interest within the data and operate on them. The argument belongs to the MSj.FilterType. Their properties are listed below:","category":"page"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"FilterType Description Arguments Specificity\nMSj.Scan Scan num Int, Vector{Int} average, chromatogram\nMSj.Level MS level Int, Vector{Int} average, chromatogram\nMSj.Polarity Polarity String, Vector{String} average, chromatogram\nMSj.Activation_Method Activation method String, Vector{String} average, chromatogram\nMSj.Activation_Energy Activation energy Real, Vector{Real} average, chromatogram\nMSj.Precursor Precursor m/z Real, Vector{Real} average, chromatogram\nMSj.RT Retention time Real, Vector{Real}, Vector{Vector{Real}} average\nMSj.IC Ion current Vector{Real} average","category":"page"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"note: Note\nThe filtering function goes first through all the arguments and setup an array of scan num that matches the conditions. Then it uses this array to calculate the average mass spectrum.  So this procedure needs two passes through the data, which is not very efficient. This is a point to make better in the future.","category":"page"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"When the argument is restricted to a single value, such as MSj.Scan(1), filtering is performed on that specific value. If the argument is a vector then filtering involves all the values within the range.  Filtering on MSj.scan([1,10]) means that the result will be obtained for scans ranging from 1 to 10.  The same applies for all FilterType with the exception of MSj.âˆ†MZ, for which the first value of the vector represents the mz and the second value represents the spread âˆ†mz, so that filtering is operated for all mz value in the range [m/z - âˆ†mz , m/z + âˆ†mz].  The MSj.RT type may take a vector or vectors as argument, such `MSj.RT([ [1,10], [20, 30] ]).  In that case, mass spectra will be averaged in [1,10]Â and [20,30] range.","category":"page"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"These filters may be combined together if necessary. For example, the input below returns the average mass spectrum for:","category":"page"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"the MS2 scans (level = 2), \nprecursor m/z 1255.5, \nupon CID activation conditions\nwith an activation energy of 18 \nand for retention times in the 1 to 60 s range.","category":"page"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"average(\"filename\", MSj.Precursor(1255.5),\n                    MSj.Activation_Energy(18),\n                    MSj.Activation_Method(\"CID\"),\n                    MSj.Level(2),\n                    MSj.RT( [1, 60] ),\n                    )","category":"page"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"Several filter types may also be combined for chromatograms:","category":"page"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"chromatogram(\"filename\", MSj.Precursor(1255.5),\n                         MSj.Activation_Energy(18),\n                         MSj.Activation_Method(\"CID\"),\n                         MSj.Level(2),\n                         )","category":"page"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"If the condition does not match any existing data, then an ErrorException is returned with the \"No matching spectra.\" message.","category":"page"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"The chromatogram function has some methods using MSj.MethodType arguments:","category":"page"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"MethodType Description Arguments Remark\nMSj.TIC Total ion current None Default\nMSj.BasePeak Base peak intensity None \nMSj.MZ m/z range Vector{Real} \nMSj.âˆ†MZ m/z Â± âˆ†mz Vector{Real} ","category":"page"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"These types control the way chromatograms are calculated: either using the total ionic current, the base peak intensity or using a m/z range.  The method argument of the MSj.chromatogramfunction is set to MSj.TIC() by default. This setting may be overruled by setting the method to desired value:","category":"page"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"chromatogram(\"filename\", method = MSj.BasePeak())\nchromatogram(\"filename\", method = MSj.MZ( [257, 259] ) ) \nchromatogram(\"filename\", method = MSj.âˆ†MZ( [258, 1] ) ) ","category":"page"},{"location":"man/filtering/#Extracting-subsets-1","page":"Combining and filtering data","title":"Extracting subsets","text":"","category":"section"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"The extract returns a Vector of MSscanfrom either a file of from a Vector{MSscan} following a load command, which corresponds to the filter conditions. See the Filtering part above.","category":"page"},{"location":"man/filtering/#","page":"Combining and filtering data","title":"Combining and filtering data","text":"sub_set = extract(\"filename\")                       # extracting without any conditions returns a vector identical to the output \nsub_set = extract(\"filename\", MSj.Level(2) )        # extract MS/MS spectra\nscans = load(\"test.mzxml\")                          # load mass spectra\nsub_set = extract(scans)                            # extract a sub_set without conditions returns the original data","category":"page"},{"location":"misc/#Miscellaneous-1","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"misc/#Logo-1","page":"Miscellaneous","title":"Logo","text":"","category":"section"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"page"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"Code used to generate the msJlogo. ","category":"page"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"using Plots\ngr()\n\n@. model(x, p) = p[4] + p[3] * exp(- ( (x-p[2])/p[1] )^2)\n\nx1 = range(-7.5, stop=-2.5, length=100)\np1 = [1, -5, 1, 0]\ny1 = model(x1,p1);\nplot(x1,y1, color = RGBA(0.884, 0.2, 0.2), fillrange = 0, fillalpha = 0.9, label = \"\", \n\tthickness_scaling = 2.0, \n    xaxis=nothing,\n    yaxis=nothing,\n    background_color=:transparent, foreground_color=:black,)\n\nx2 = range(-2.5, stop=2.5, length=100)\np2 = [1, 0, 2, 0]\ny2 = model(x2, p2)\nplot!(x2,y2, color= RGBA(0.22, 0.596, 0.149), fillrange = 0, fillalpha = 0.9, label = \"\")\n\nx3 = range(2.5, stop=7.5, length=100)\np3 = [1, 5, 1, 0]\ny3 = model(x3,p3)\nplot!(x3,y3,color = RGBA(0.584, 0.345, 0.608), fillrange = 0, fillalpha = 0.9, label = \"\")\n\nx4 = range(-17.5, stop=-12.5, length=100)\np4 = [1, -15, 1, 0]\ny4 = model(x4,p4);\nplot!(x4,y4, color = RGBA(0.255, 0.412, 0.882), fillrange = 0, fillalpha = 0.9, label = \"\")\n\nsavefig(\"docs/src/assets/logo.png\")","category":"page"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"(Image: logo)","category":"page"},{"location":"man/importing/#Importing-data-1","page":"Importing data","title":"Importing data","text":"","category":"section"},{"location":"man/importing/#","page":"Importing data","title":"Importing data","text":"When loading a file containing more than a single acquisition, the individual mass spectrometry scans are pushed into an array of MSj.MSscan.  The individual scans may be retrieve from the array the usual way:","category":"page"},{"location":"man/importing/#","page":"Importing data","title":"Importing data","text":"julia> scans = load(\"filename\")\n51-element Array{MSj.MSscan,1}:\n MSj.MSscan(1, 0.1384, 5.08195e6, [140.083, 140.167, 140.25, 140.333, 140.417, 140.5, 140.583, 140.667, 140.75, 140.833  â€¦  1999.25, 1999.33, 1999.42, ....)\n...\n\njulia> scans[1]\nMSj.MSscan(1, 0.1384, 5.08195e6, [140.083, 140.167, 140.25, 140.333, 140.417, 140.5, 140.583, 140.667, 140.75, 140.833  â€¦  1999.25, 1999.33, 1999.42, ....)","category":"page"},{"location":"man/importing/#","page":"Importing data","title":"Importing data","text":"As mentioned above, chromatograms may be retrieved from a file and imported in MSj.Chromatogram :","category":"page"},{"location":"man/importing/#","page":"Importing data","title":"Importing data","text":"julia> chromatogram(\"filename\")\nMSj.Chromatogram([0.1384, 0.7307, 2.1379, 3.7578, 4.3442, 5.7689], [5.08195e6, 9727.2, 11.3032, 4.8084e6, 12203.5, 4.84455], 5.08195e6)","category":"page"},{"location":"man/importing/#","page":"Importing data","title":"Importing data","text":"The function MSj.retention_time reads the retention time of an input file and returns a Vector{Float64}containing the time in seconds.","category":"page"},{"location":"man/importing/#","page":"Importing data","title":"Importing data","text":"julia> MSj.retention_time(\"filename\")\n51-element Array{Float64,1}:\n  0.1384\n  0.7307\n  2.1379\n....MSj.FilterType\n","category":"page"},{"location":"man/information/#Information-1","page":"File Information","title":"Information","text":"","category":"section"},{"location":"man/information/#","page":"File Information","title":"File Information","text":"The info public function reads the content of a file, but without loading the mass spectrometry data, and returns a Vector{String}containing the number of scans, scans level and for MS/MS data, the precursor m/z, the activation method and energy. Additional information may be gained by setting verbose = true.","category":"page"},{"location":"man/information/#","page":"File Information","title":"File Information","text":"info(filename)\n4-element Array{String,1}:\n \"51 scans\"\n \"MS1+\"\n \"MS2+ 1255.5  CID(CE=18)\"\n \"MS3+ 902.33  PQD(CE=35)\"","category":"page"},{"location":"man/public/#Public-elements-1","page":"Public elements","title":"Public elements","text":"","category":"section"},{"location":"man/public/#","page":"Public elements","title":"Public elements","text":"The functions below are exported:","category":"page"},{"location":"man/public/#","page":"Public elements","title":"Public elements","text":"info \nload \nchromatogram\naverage\nbaseline_correction\nextract\ncentroid\nsmooth\nisotopic_distribution\nmasses\nsimulate","category":"page"},{"location":"man/plotting/#Plotting-1","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"Plotting facilities are available as a submodule to the MSj package.  The MSj.plots module relies on the RecipesBase package, which allows writing recipes to plot users' data types. Hence, recipes have been created for MSscan, Msscans and Chromatogram:","category":"page"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"plot(scans[1], method = :relative))\n","category":"page"},{"location":"man/plotting/#","page":"Plotting","title":"Plotting","text":"By default plotting is made in relative intensities, which may be changed by setting method to :absolute.","category":"page"},{"location":"reference/#","page":"References","title":"References","text":"CurrentModule = MSj\nDocTestSetup  = quote\n    using LightXML\nend","category":"page"},{"location":"reference/#","page":"References","title":"References","text":"This page lists all the documented elements of the MSj.jl package covering all modules and submodules.","category":"page"},{"location":"reference/#","page":"References","title":"References","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Main-module-1","page":"References","title":"Main module","text":"","category":"section"},{"location":"reference/#","page":"References","title":"References","text":"MSj","category":"page"},{"location":"reference/#MSj.MSj","page":"References","title":"MSj.MSj","text":"Main module for MSj.jlâ€“ A Julia package to load and process mass spectrometry data.\n\n\n\n\n\n","category":"module"},{"location":"reference/#Types-1","page":"References","title":"Types","text":"","category":"section"},{"location":"reference/#","page":"References","title":"References","text":"","category":"page"},{"location":"reference/#","page":"References","title":"References","text":"Submodule with types and structures used to stored the data and dispatch to the right methods.","category":"page"},{"location":"reference/#Data-types-1","page":"References","title":"Data types","text":"","category":"section"},{"location":"reference/#","page":"References","title":"References","text":"MSj.MScontainer\nMSj.MSscan\nMSj.MSscans\nMSj.Chromatogram\nMSj.Isotope","category":"page"},{"location":"reference/#MSj.MScontainer","page":"References","title":"MSj.MScontainer","text":"abstract type MScontainer  end\n\nAbstract type containing any imported data belongs to the MScontainer type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.MSscan","page":"References","title":"MSj.MSscan","text":"struct MSscan <: MScontainer\n\nData structure used to store individual mass spectrometry scans organized following the structure of mzXML files.\n\nstruct MSscan <: MScontainer      \n    num::Int                          # num\n    rt::Float64                       # retentionTime\n    tic::Float64                      # totIonCurrent\n    mz::Vector{Float64}               # m/z\n    int::Vector{Float64}              # intensity\n    level::Int                        # msLevel\n    basePeakMz::Float64               # basePeakMz\n    basePeakIntensity::Float64        # basePeakIntensity\n    precursor::Float64                # precursorMz\n    polarity::String                  # polarity\n    activationMethod::String          # activationMethod\n    collisionEnergy::Float64          # collisionEnergy\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.MSscans","page":"References","title":"MSj.MSscans","text":"struct MSscans  <: MScontainer\n\nData structure designed to store mass spectra obtained after filtering operation along with the history of these operation.\n\nstruct MSscans  <: MScontainer        \n    num::Vector{Int}                  # num\n    rt::Vector{Float64}               # retentionTime\n    tic::Float64                      # totIonCurrent\n    mz::Vector{Float64}               # m/z\n    int::Vector{Float64}              # intensity\n    level::Vector{Int}                # msLevel\n    basePeakMz::Float64               # basePeakMz\n    basePeakIntensity::Float64        # basePeakIntensity\n    precursor::Vector{Float64}        # precursorMz\n    polarity::Vector{String}          # polarity\n    activationMethod::Vector{String}  # activationMethod\n    collisionEnergy::Vector{Float64}  # collisionEnergy\n    s::Vector{Float64}                # variance\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.Chromatogram","page":"References","title":"MSj.Chromatogram","text":"struct Chromatogram  <: MScontainer\n\nData structure used to retrieve chromatography data.\n\nstruct Chromatogram  <: MScontainer   \n    rt::Vector{Float64}               # retention time\n    ic::Vector{Float64}               # ion current\n    maxic::Float64\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.Isotope","page":"References","title":"MSj.Isotope","text":"struct Isotope\n\nData structure used to store individual properties of the isotopes.\n\nstruct Isotope\n    m::Float64           # mass\n    f::Float64           # natural frequency\n    logf::Float64        # logarythm of the natural frequency\n    Z::Int               # atomic number\n    A::Int               # mass number\n    active::Bool         # is radioactive\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#Methods-Types-1","page":"References","title":"Methods Types","text":"","category":"section"},{"location":"reference/#","page":"References","title":"References","text":"MSj.MethodType\nMSj.BasePeak\nMSj.TIC\nMSj.âˆ†MZ\nMSj.MZ\nMSj.SG\nMSj.TBPD\nMSj.SNRA\nMSj.TopHat\nMSj.LOESS\nMSj.IPSA","category":"page"},{"location":"reference/#MSj.MethodType","page":"References","title":"MSj.MethodType","text":"abstract type MethodType  end\n\nType containing all the methods used for filtering the data.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.BasePeak","page":"References","title":"MSj.BasePeak","text":"struct BasePeak <: MethodType\n\nStructure for multiple dispatching to retrieve base peak chromatogram.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.TIC","page":"References","title":"MSj.TIC","text":"struct TIC <: MethodType\n\nDispatching to retrieve total ion current chromatogram.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.âˆ†MZ","page":"References","title":"MSj.âˆ†MZ","text":"struct âˆ†MZ{argT <: Union{Real, AbstractVector{<:Real} }} <: MethodType\n\nStructure for multiple dispatching to retrieve extracted ion current chromatogram around an m/z Â± âˆ†mz value given by arg = [mz, âˆ†mz]\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.MZ","page":"References","title":"MSj.MZ","text":"struct MZ{argT <: Union{Real, AbstractVector{<:Real} }} <: MethodType\n\nStructure for multiple dispatching to retrieve extracted ion current chromatogram around for m/z in the range arg = [mz1, mz2].\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.SG","page":"References","title":"MSj.SG","text":"struct SG{argT <: Int} <: MethodType   #Savinsky & Golay filtering\n\nStructure for multiple dispatching to Savinsky & Golay filtering, providing the order, window size and derivative to be performed.  Defaults values are provided in functions calls.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.TBPD","page":"References","title":"MSj.TBPD","text":"struct TBPD{argT1 <: Symbol, argT2 <: Real}  <: MethodType\n\nStructure for multiple dispatching to Template Base Peak Detection centroiding, providing the shape of the template function, the resolution and threshold.  Defaults values are provided in functions calls.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.SNRA","page":"References","title":"MSj.SNRA","text":"struct SNRA{argT1 <: Real, argT2 <: Int}  <: MethodType\n\nStructure for multiple dispatching to Signal to Noise Ratio Analysis centroiding, providing the threshold value and the size of the region.  Defaults values are provided in functions calls.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.TopHat","page":"References","title":"MSj.TopHat","text":"TopHat{argT <: Int} <: MethodType\n\nStructure for multiple dispatching to TopHat baseline correction. Region is used specify the dimention over which this operation performed\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.LOESS","page":"References","title":"MSj.LOESS","text":"LOESS{argT <: Int} <: MethodType\n\nStructure for multiple dispatching to LOcally Weighted Error Sum of Squares regression (LOESS) baseline correction.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.IPSA","page":"References","title":"MSj.IPSA","text":"struct IPSA{argT1 <: Int, argT2 <: Real} <: MethodType\n\nStructure for multiple dispatching to iterative polynomial smoothing algorithm (IPSA) baseline correction.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Filters-1","page":"References","title":"Filters","text":"","category":"section"},{"location":"reference/#","page":"References","title":"References","text":"MSj.FilterType\nMSj.RT\nMSj.IC\nMSj.Level\nMSj.Scan\nMSj.Polarity\nMSj.Activation_Method\nMSj.Activation_Energy\nMSj.Precursor\nMSj.Isotopes","category":"page"},{"location":"reference/#MSj.FilterType","page":"References","title":"MSj.FilterType","text":"abstract type FilterType end\n\nThis type contains  the structures for filtering the data.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.RT","page":"References","title":"MSj.RT","text":"RT{argT <: Union{Real, AbstractVector{<:Real},  AbstractVector{<:AbstractVector{<:Real}} }}\n\nThis type contains  the structures for filtering the data.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.IC","page":"References","title":"MSj.IC","text":"struct IC{argT <: Union{Real, AbstractVector{<:Real} }} <: FilterType\n\nUsed for multiple dispatching to Template Base Peak Detection centroiding, providing the shape of the template function, the resolution and threshold.  Defaults values are provided in functions calls.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.Level","page":"References","title":"MSj.Level","text":"struct Level{argT <: Union{Int, AbstractVector{<:Int} }} <: FilterType\n\nUsed to dispatch filters to MS level.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.Scan","page":"References","title":"MSj.Scan","text":" Scan{argT <: Union{Int, AbstractVector{<:Int} }} <: FilterType\n\nDispatch filter to scan num.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.Polarity","page":"References","title":"MSj.Polarity","text":"struct Polarity{argT <: Union{String, AbstractVector{<:String} }} <: FilterType\n\nDispatch filter to polarity.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.Activation_Method","page":"References","title":"MSj.Activation_Method","text":"struct Activation_Method{argT <: Union{String, AbstractVector{<:String} }} <: FilterType\n\nDispatch filter to activation methods\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.Activation_Energy","page":"References","title":"MSj.Activation_Energy","text":"struct Activation_Energy{argT <: Union{Real, AbstractVector{<:Real} }} <: FilterType\n\nDispatch filter to activation energies.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MSj.Precursor","page":"References","title":"MSj.Precursor","text":"struct Precursor{argT <: Union{Real, AbstractVector{<:Real} }} <: FilterType\n\nDispatch filter to precursor.\n\n\n\n\n\n","category":"type"},{"location":"reference/#I/O-1","page":"References","title":"I/O","text":"","category":"section"},{"location":"reference/#","page":"References","title":"References","text":"","category":"page"},{"location":"reference/#","page":"References","title":"References","text":"Module for importing and exporting data. Dispatch to specific methods according to the file extension","category":"page"},{"location":"reference/#","page":"References","title":"References","text":"MSj.info(filename::String; verbose::Bool = false)\nMSj.load(filename::String)\nMSj.retention_time(filename::String)\nMSj.chromatogram(filename::String, filters::FilterType...; method::MethodType=TIC())\nMSj.average(filename::String, arguments::FilterType...; stats::Bool=true)","category":"page"},{"location":"reference/#MSj.info-Tuple{String}","page":"References","title":"MSj.info","text":"info(filename::String, verbose::Bool = false)\n\nThe function looks into an file and returns in an Array{String} containing the number of scans and the different scans described by their MS level, polarity and eventually the precursor m/z followed by the activation method and collision energy. Each entry is unique, which gives a summary of the input file. With verbose = true, the functions also returns the parentFile, msManufacturer, msModel, msIonisation, msMassAnalyzer, msDetector, software and dataProcessing if existing.\n\nExample\n\njulia> info(\"test1.mzXML\")\n4-element Array{String,1}:\n \"51 scans\"               \n \"MS1+\"                   \n \"MS2+ 1255.5  CID(CE=18)\"\n \"MS3+ 902.33  PQD(CE=35)\"\njulia> MSj.info(\"test1.mzXML\", verbose = true)\n12-element Array{String,1}:\n \"parentFile: test1_MSj_1.raw\"\n \"msManufacturer: Thermo Finnigan\"\n \"msModel: LTQ XL\"      \n \"msIonisation: ESI\"\n \"msMassAnalyzer: ITMS\"\n \"msDetector: unknown\"\n \"software: Xcalibur, 2.6.0 SP3\"\n \"dataProcessing: conversion, ReAdW 4.3.1(build Sep  9 2009 12:30:29)\"\n \"51 scans\"\n \"MS1+\"\n \"MS2+ 1255.5  CID(CE=18)\"\n \"MS3+ 902.33  PQD(CE=35)\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.load-Tuple{String}","page":"References","title":"MSj.load","text":"function load(filename::String)\n\nChecks the file extension and calls the right function to load the mass spectra if it exists. Returns an array of MSj.MSscan where the individual mass spectra are stored. \n\nExamples\n\njulia> scans = load(\"test.mzXML\")\n51-element Array{MSj.MSscan,1}:\n MSj.MSscan(1, 0.1384, 5.08195e6, [140.083, 140.167, 140.25, 140.333, 140.417, 140.5, 140.583, 140.667, 140.75, 140.833  â€¦  1999.25, 1999.33, 1999.42, ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.retention_time-Tuple{String}","page":"References","title":"MSj.retention_time","text":"retention_time(filename::String)\n\nReturns an array composed of the retention times of the individual mass spectra. \n\nExamples\n\njulia> retention_time(\"test.mzXML\")\n51-element Array{Float64,1}:\n  0.1384\n  0.7307\n  2.1379\n....\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.chromatogram-Tuple{String,Vararg{MSj.FilterType,N} where N}","page":"References","title":"MSj.chromatogram","text":"chromatogram(filename::String, filters::FilterType...; method::MethodType=TIC())\n\nReturns a structure holding the retention time (rt),  the ion current (ic) and the maximum value (maxic) for all the mass spectra within the file. Alternatively, other options may be supplied such as method = MSj.BasePeak, which returns the base peak intensity, method = MSj.âˆ†MZ([500,5]), which returns the ion current for the range mz = 500 Â± 5, or method = MSj.MZ([200,1000]) which return the ion current in the range from m/z 200 to m/z 1000.  The data may be filtered by ms level, precursor mass, activation methods, etc, using the arguments MSj.Level(N), MSj.Precursor(mz), MSj.Activation_Method(\"method\")...\n\nExamples\n\njulia> rt, ic = chromatogram(\"test.mzxml\")\n([0.1384  â€¦  60.4793], [4.74795e6  â€¦  17.4918])\njulia> rt, ic = chromatogram(\"test.mzxml\", method = MSj.BasePeak() )\n([0.1384  â€¦  60.4793], [102558.0  â€¦  1.23181])\njulia> rt, ic = chromatogram(\"test.mzxml\", method = MSj.âˆ†MZ([500,5]) )\n([0.1384  â€¦  60.4793], [46036.6  â€¦  14.2529])\njulia> rt, ic = chromatogram(\"test.mzxml\", method = MSj.MZ([200,1000]))\n([0.1384  â€¦  60.4793], [4.74795e6  â€¦  17.4918])\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.average-Tuple{String,Vararg{MSj.FilterType,N} where N}","page":"References","title":"MSj.average","text":"average(filename::String, arguments::FilterType...; stats::Bool=true)\n\nReturns the average mass spectrum container (MSscans) along with the sample standard deviation of the intensities with stats=true (default) for all the mass spectra within file. The data may be filtered by level, precursor mass, activation methods, etc, using the arguments MSj.Level(N), MSj.Precursor(mz), MSj.Activation_Method(\"method\"), or any combination of these arguments.\n\nExamples\n\njulia> spectrum = average(\"test.mzxml\")\nMSj.MSscans([1, 2, 3 ....\njulia> spectrum = average(\"test.mzxml\", MSj.Level(1) )\nMSj.MSscans([1, 4, 7, 10,\njulia> spectrum = average(\"test.mzxml\", MSj.Precursor(1255.5) )\nMSj.MSscans([2, 5, 8, 11, ...\njulia> spectrum = average(\"test.mzxml\", MSj.Activation_Method(\"PQD\") )\nMSj.MSscans([3, 6, 9, 12, 15,\njulia> spectrum = average(\"test.mzxml\", MSj.Activation_Method(\"PQD\"), MSj.Polarity(\"+\"), MSj.RT([10,20]))\nMSj.MSscans([9, 12, 15, 18], ...\n\n\n\n\n\n","category":"method"},{"location":"reference/#mzXML-1","page":"References","title":"mzXML","text":"","category":"section"},{"location":"reference/#","page":"References","title":"References","text":"","category":"page"},{"location":"reference/#","page":"References","title":"References","text":"Interface to the mzxml file format","category":"page"},{"location":"reference/#","page":"References","title":"References","text":"MSj.info_mzxml\nMSj.load_mzxml_all\nMSj.load_mzxml\nMSj.load_mzxml_spectrum\nMSj.retention_time(msRun::XMLElement)\nMSj.average(filename::String, arguments::FilterType...; stats::Bool=true\nMSj.filter(msRun::XMLElement, argument::Level{<:Int})\nMSj.filter(msRun::XMLElement, argument::Level{<:AbstractVector})\nMSj.filter(msRun::XMLElement, argument::Scan{<:Int})\nMSj.filter(msRun::XMLElement, argument::Scan{<:AbstractVector})\nMSj.filter(msRun::XMLElement, argument::Polarity{<:String})\nMSj.filter(msRun::XMLElement, argument::Polarity{<:AbstractVector})\nMSj.filter(msRun::XMLElement, argument::RT{<:Real})\nMSj.filter(msRun::XMLElement, argument::RT{<:AbstractVector})\nMSj.filter(msRun::XMLElement, argument::RT{<:AbstractVector{<:AbstractVector} } )\nMSj.filter(msRun::XMLElement, argument::IC{<:AbstractVector})\nMSj.filter(msRun::XMLElement, argument::Precursor{<:Real})\nMSj.filter(msRun::XMLElement, argument::Precursor{<:AbstractVector})\nMSj.filter(msRun::XMLElement, argument::Activation_Energy{<:Real})\nMSj.filter(msRun::XMLElement, argument::Activation_Energy{<:AbstractVector})\nMSj.filter(msRun::XMLElement, argument::Activation_Method{<:String})\nMSj.filter(msRun::XMLElement, argument::Activation_Method{<:AbstractVector})\nMSj.extracted_chromatogram(filename::String, indices::Vector{Int},method::MethodType)\nMSj.composite_spectra(filename::String, indices::Vector{Int}, stats::Bool)","category":"page"},{"location":"reference/#MSj.info_mzxml","page":"References","title":"MSj.info_mzxml","text":"info_mzxml(filename::String, info::Vector{String}, verbose::Bool=false)\n\nReturns the information content of an mzXML file into a string. Verbosity is controlled by the verbose Boolean variable set by default to false.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MSj.load_mzxml_all","page":"References","title":"MSj.load_mzxml_all","text":"load_mzxml_all(filename::String)\n\nLoad an entire an mzxml file, and return the  \n\n\n\n\n\n","category":"function"},{"location":"reference/#MSj.load_mzxml","page":"References","title":"MSj.load_mzxml","text":"load_mzxml(filename::String, index::Int\n\nLoad from an mzxml file the scan num that match the input index\n\n\n\n\n\n","category":"function"},{"location":"reference/#MSj.load_mzxml_spectrum","page":"References","title":"MSj.load_mzxml_spectrum","text":"load_mzxml_spectrum(c::XMLElement)\n\nFrom an XMLElement, returns the data into an MSscan. \n\n\n\n\n\n","category":"function"},{"location":"reference/#MSj.retention_time-Tuple{LightXML.XMLElement}","page":"References","title":"MSj.retention_time","text":"retention_time(msRun::XMLElement)\n\nFrom an XMLE element returns the retention time.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Filtering-1","page":"References","title":"Filtering","text":"","category":"section"},{"location":"reference/#","page":"References","title":"References","text":"MSj.average(scans::Vector{MSscan}, arguments::FilterType...; stats::Bool=true)\nMSj.chromatogram(scans::Vector{MSscan}, filters::FilterType...; method::MethodType=TIC())\nMSj.retention_time(scans::Vector{MSscan})\nMSj.filter(scans::Vector{MSscan}, argument::Scan{<:Int})\nMSj.filter(scans::Vector{MSscan}, argument::Scan{<:AbstractVector})\nMSj.filter(scans::Vector{MSscan}, argument::Level{<:Int})\nMSj.filter(scans::Vector{MSscan}, argument::Level{<:AbstractVector})\nMSj.filter(scans::Vector{MSscan}, argument::Precursor{<:Real})\nMSj.filter(scans::Vector{MSscan}, argument::Precursor{<:AbstractVector})\nMSj.filter(scans::Vector{MSscan}, argument::Activation_Energy{<:Real})\nMSj.filter(scans::Vector{MSscan}, argument::Activation_Energy{<:AbstractVector})\nMSj.filter(scans::Vector{MSscan}, argument::Activation_Method{<:String})\nMSj.filter(scans::Vector{MSscan}, argument::Activation_Method{<:AbstractVector})\nMSj.filter(scans::Vector{MSscan}, argument::Polarity{<:String})\nMSj.filter(scans::Vector{MSscan}, argument::Polarity{<:AbstractVector})\nMSj.filter(scans::Vector{MSscan}, argument::RT{<:Real}) \nMSj.filter(scans::Vector{MSscan}, argument::RT{<:AbstractVector})\nMSj.filter(scans::Vector{MSscan}, argument::RT{<:AbstractVector{<:AbstractVector} } )\nMSj.filter(scans::Vector{MSscan}, argument::IC{<:AbstractVector})\nMSj.extracted_chromatogram(scans::Vector{MSscan}, indices::Vector{Int},method::MethodType)\nMSj.composite_spectra(scans::Vector{MSscan}, indices::Vector{Int}, stats::Bool)","category":"page"},{"location":"reference/#MSj.average-Tuple{Array{MSj.MSscan,1},Vararg{MSj.FilterType,N} where N}","page":"References","title":"MSj.average","text":"average(scans::Vector{MSscan}, arguments::FilterType...; stats::Bool=true)\n\nReturns the average mass spectrum container (MSscans) along with the sample standard deviation of the intensities with stats=true (default) for all the mass spectra within the Array of mass spectrum container MSscan.. The data may be filtered by level, precursor mass, activation methods, etc, using the arguments MSj.Level(N), MSj.Precursor(mz), MSj.Activation_Method(\"method\"), or any combination of these arguments.\n\nExamples\n\njulia> spectrum = average(\"test.mzxml\")\nMSj.MSscans([1, 2, 3 ....\njulia> spectrum = average(\"test.mzxml\", MSj.Level(1) )\nMSj.MSscans([1, 4, 7, 10,\njulia> spectrum = average(\"test.mzxml\", MSj.Precursor(1255.5) )\nMSj.MSscans([2, 5, 8, 11, ...\njulia> spectrum = average(\"test.mzxml\", MSj.Activation_Method(\"PQD\") )\nMSj.MSscans([3, 6, 9, 12, 15,\njulia> spectrum = average(\"test.mzxml\", MSj.Activation_Method(\"PQD\"), MSj.Polarity(\"+\"), MSj.RT([10,20]))\nMSj.MSscans([9, 12, 15, 18], ...\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.chromatogram-Tuple{Array{MSj.MSscan,1},Vararg{MSj.FilterType,N} where N}","page":"References","title":"MSj.chromatogram","text":"chromatogram(scans::Vector{MSscan}, filters::FilterType...; method::MethodType=TIC())\n\nReturns the retention time and the total ion current by default for all the mass spectra within the Array of mass spectrum container MSscan. Alternatively, other options may be supplied such as method = MSj.BasePeak, which returs the base peak intensity, method = MSj.âˆ†MZ([500,5]), which returns the ion current for the range mz = 500 Â± 5, or method = MSj.MZ([200,1000]) which return the ion current in the range from m/z 200 to m/z 1000.  The data may be filtered by ms level, precursor mass, activation methods, etc, using the arguments MSj.Level(N), MSj.Precursor(mz), MSj.Activation_Method(\"method\")...\n\nExamples\n\njulia> rt, ic = chromatogram(\"test.mzxml\")\n([0.1384  â€¦  60.4793], [4.74795e6  â€¦  17.4918])\njulia> rt, ic = chromatogram(\"test.mzxml\", method = MSj.BasePeak() )\n([0.1384  â€¦  60.4793], [102558.0  â€¦  1.23181])\njulia> rt, ic = chromatogram(\"test.mzxml\", method = MSj.âˆ†MZ([500,5]) )\n([0.1384  â€¦  60.4793], [46036.6  â€¦  14.2529])\njulia> rt, ic = chromatogram(\"test.mzxml\", method = MSj.MZ([200,1000]))\n([0.1384  â€¦  60.4793], [4.74795e6  â€¦  17.4918])\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.retention_time-Tuple{Array{MSj.MSscan,1}}","page":"References","title":"MSj.retention_time","text":"retention_time(scans::Vector{MSscan})\n\nReturns an array composed of the retention times of the individual mass spectra. \n\nExamples\n\njulia> retention_time(\"scans\")\n51-element Array{Float64,1}:\n  0.1384\n  0.7307\n  2.1379\n....\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.filter-Tuple{Array{MSj.MSscan,1},MSj.Scan{#s3} where #s3<:Int64}","page":"References","title":"MSj.filter","text":"filter(scans::Vector{MSscan}, argument::Scan{<:Int})\n\nSearch for scans matching the argument scan num and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.filter-Tuple{Array{MSj.MSscan,1},MSj.Scan{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"References","title":"MSj.filter","text":"filter(scans::Vector{MSscan}, argument::Scan{<:AbstractVector})\n\nSearch for scans matching the argument scan nums and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.filter-Tuple{Array{MSj.MSscan,1},MSj.Level{#s3} where #s3<:Int64}","page":"References","title":"MSj.filter","text":"filter(scans::Vector{MSscan}, argument::Level{<:Int})\n\nSearch for scans matching the argument MS level and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.filter-Tuple{Array{MSj.MSscan,1},MSj.Level{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"References","title":"MSj.filter","text":"filter(scans::Vector{MSscan}, argument::Level{<:AbstractVector})\n\nSearch for scans matching the argument MS levels and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.filter-Tuple{Array{MSj.MSscan,1},MSj.Precursor{#s3} where #s3<:Real}","page":"References","title":"MSj.filter","text":"filter(scans::Vector{MSscan}, argument::Precursor{<:Real})\n\nSearch for scans matching the argument precursor mz and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.filter-Tuple{Array{MSj.MSscan,1},MSj.Precursor{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"References","title":"MSj.filter","text":"filter(scans::Vector{MSscan}, argument::Precursor{<:AbstractVector})\n\nSearch for scans matching the argument precursors mz and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.filter-Tuple{Array{MSj.MSscan,1},MSj.Activation_Energy{#s3} where #s3<:Real}","page":"References","title":"MSj.filter","text":"filter(scans::Vector{MSscan}, argument::Activation_Energy{<:Real})\n\nSearch for scans matching the argument activation energy and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.filter-Tuple{Array{MSj.MSscan,1},MSj.Activation_Energy{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"References","title":"MSj.filter","text":"filter(scans::Vector{MSscan}, argument::Activation_Energy{<:AbstractVector})\n\nSearch for scans matching the argument activation energies and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.filter-Tuple{Array{MSj.MSscan,1},MSj.Activation_Method{#s3} where #s3<:String}","page":"References","title":"MSj.filter","text":"filter(scans::Vector{MSscan}, argument::Activation_Method{<:String})\n\nSearch for scans matching the argument activation method and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.filter-Tuple{Array{MSj.MSscan,1},MSj.Activation_Method{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"References","title":"MSj.filter","text":"filter(scans::Vector{MSscan}, argument::Activation_Method{<:AbstractVector})\n\nSearch for scans matching the argument activation methods and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.filter-Tuple{Array{MSj.MSscan,1},MSj.Polarity{#s3} where #s3<:String}","page":"References","title":"MSj.filter","text":"filter(scans::Vector{MSscan}, argument::Polarity{<:String})\n\nSearch for scans matching the argument polarity and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.filter-Tuple{Array{MSj.MSscan,1},MSj.Polarity{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"References","title":"MSj.filter","text":"filter(scans::Vector{MSscan}, argument::Polarity{<:AbstractVector})\n\nSearch for scans matching the argument polarities and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.filter-Tuple{Array{MSj.MSscan,1},MSj.RT{#s3} where #s3<:Real}","page":"References","title":"MSj.filter","text":"filter(scans::Vector{MSscan}, argument::RT{<:Real})\n\nSearch for scans matching the argument retention time and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.filter-Tuple{Array{MSj.MSscan,1},MSj.RT{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"References","title":"MSj.filter","text":"filter(scans::Vector{MSscan}, argument::RT{<:AbstractVector})\n\nSearch for scans matching the argument retention time in the specified range and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.filter-Tuple{Array{MSj.MSscan,1},MSj.RT{#s3} where #s3<:(AbstractArray{#s2,1} where #s2<:(AbstractArray{T,1} where T))}","page":"References","title":"MSj.filter","text":"filter(scans::Vector{MSscan}, argument::RT{<:AbstractVector{<:AbstractVector} } )\n\nSearch for scans matching the argument retention time in the specified ranges and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.filter-Tuple{Array{MSj.MSscan,1},MSj.IC{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"References","title":"MSj.filter","text":"filter(scans::Vector{MSscan}, argument::IC{<:AbstractVector})\n\nSearch for scans matching the argument total ion current within the specified ranges and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.extracted_chromatogram-Tuple{Array{MSj.MSscan,1},Array{Int64,1},MSj.MethodType}","page":"References","title":"MSj.extracted_chromatogram","text":"extracted_chromatogram(scans::Vector{MSscan}, indices::Vector{Int},method::MethodType)\n\nReturns the extracted chromatogram for input Array of MSscan according to the selected method and for set of scan num as input\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.composite_spectra-Tuple{Array{MSj.MSscan,1},Array{Int64,1},Bool}","page":"References","title":"MSj.composite_spectra","text":"composite_spectra(scans::Vector{MSscan}, indices::Vector{Int}, stats::Bool)\n\nReturns the average MSscans for input Array of MSscan and according to the input scan num. Calculation of variance is controlled by the stats Boolean variable.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Extracting-subsets-1","page":"References","title":"Extracting subsets","text":"","category":"section"},{"location":"reference/#","page":"References","title":"References","text":"MSj.extract(filename::String, arguments::FilterType...)\nMSj.extract(scans::Vector{MSscan}, arguments::FilterType...)\nMSj.build_subset(filename::String, indices::Vector{Int})\nMSj.build_subset(scans::Vector{MSscan}, indices::Vector{Int})","category":"page"},{"location":"reference/#MSj.extract-Tuple{String,Vararg{MSj.FilterType,N} where N}","page":"References","title":"MSj.extract","text":"extract(filename::String, arguments::FilterType...)\n\nSearch for scans matching the argument MS level and returns an array of matching MSscans otherwise returns an ErrorException: \"No matching spectra found.\"\n\nExamples\n\njulia> sub_set = extract(\"test.mzxml\")\n6-element Array{MSj.MSscan,1}:\n MSj.MSscan(1, 0.1384, 5.08195e6, [140.083, 140.167, 140.25, 140.333, 140.417, 140.5, 140.583, 140.667, 140.75, 140.833  â€¦  1999.25, 1999.33, 1999.42, ....\njulia> sub_set = extract(\"test.mzxml\", MSj.Level(2) )      # extract MS/MS spectra\nMSj.MSscan(2, 0.7307, 9727.2, [345.083, 345.167, 345.25, 345.333, 345.417, 345.5, 345.583, 345.667, 345.75, 345.833  â€¦  1999.25, 1999.33, 1999.42, 1999.5, 1999.58 ....\n MSj.MSscan(5, 4.3442, 12203.5, [345.083, 345.167, 345.25, 345.333, 345.417, 345.5, 345.583, 345.667, 345.75, 345.833  â€¦  1999.25, 1999.33, 1999.42, 1999.5, 1999.58, ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.extract-Tuple{Array{MSj.MSscan,1},Vararg{MSj.FilterType,N} where N}","page":"References","title":"MSj.extract","text":"extract(scans::Vector{MSscan}, arguments::FilterType...)\n\nSearch for scans matching the argument MS level and returns an array of matching MSscans otherwise returns an ErrorException: \"No matching spectra found.\"\n\nExamples\n\njulia> scans = load(\"test.mzxml\")                          # load mass spectra\n6-element Array{MSj.MSscan,1}:\n MSj.MSscan(1, 0.1384, 5.08195e6, [140.083, 140.167, 140.25, 140.333, 140.417, 140.5, 140.583, 140.667, 140.75, 140.833  â€¦  1999.25, 1999.33, 1999.42, ...\njulia> sub_set = extract(scans)                            # extract a sub_set without conditions returns the original data\n6-element Array{MSj.MSscan,1}:\n MSj.MSscan(1, 0.1384, 5.08195e6, [140.083, 140.167, 140.25, 140.333, 140.417, 140.5, 140.583, 140.667, 140.75, 140.833  â€¦  1999.25, 1999.33, 1999.42, ....\njulia> sub_set = extract(scans, MSj.Level(2) )      # extract MS/MS spectra\nMSj.MSscan(2, 0.7307, 9727.2, [345.083, 345.167, 345.25, 345.333, 345.417, 345.5, 345.583, 345.667, 345.75, 345.833  â€¦  1999.25, 1999.33, 1999.42, 1999.5, 1999.58 ....\n MSj.MSscan(5, 4.3442, 12203.5, [345.083, 345.167, 345.25, 345.333, 345.417, 345.5, 345.583, 345.667, 345.75, 345.833  â€¦  1999.25, 1999.33, 1999.42, 1999.5, 1999.58, ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.build_subset-Tuple{String,Array{Int64,1}}","page":"References","title":"MSj.build_subset","text":"build_subset(filename::String, indices::Vector{Int})\n\nReturns a Vector of MSscan from the input file according to the scan num (indices).\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.build_subset-Tuple{Array{MSj.MSscan,1},Array{Int64,1}}","page":"References","title":"MSj.build_subset","text":"build_subset(scans::Vector{MSscan}, indices::Vector{Int})\n\nReturns a Vector of MSscan according to the input scan num.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Process-1","page":"References","title":"Process","text":"","category":"section"},{"location":"reference/#","page":"References","title":"References","text":"","category":"page"},{"location":"reference/#Mass-spectrum-1","page":"References","title":"Mass spectrum","text":"","category":"section"},{"location":"reference/#","page":"References","title":"References","text":"","category":"page"},{"location":"reference/#","page":"References","title":"References","text":"MSj.smooth(scan::MScontainer; method::MethodType=SG(5, 9, 0))\nMSj.smooth(scans::Vector{MSscan}; method::MethodType=SG(5, 9, 0))\nMSj.savitzky_golay_filtering(scan::MScontainer, order::Int, window::Int, deriv::Int)\nMSj.centroid(scan::MScontainer; method::MethodType=SNRA(1., 100) )\nMSj.centroid(scans::Vector{MSscan}; method::MethodType=SNRA(1., 100) \nMSj.snra(scan::MScontainer, thres::Real, region::Int)\nMSj.tbpd(scan::MScontainer, model::Function,  âˆ†mz::Real, thres::Real)\nMSj.gauss(x::Float64, p::Vector{Float64})\nMSj.lorentz(x::Float64, p::Vector{Float64})\nMSj.voigt(x::Float64, p::Vector{Float64})\nMSj.tbpd(scan::MScontainer, shape::Symbol,  R::Real, thres::Real)\nMSj.baseline_correction(scan::MScontainer; method::MethodType=TopHat(100) )\nMSj.baseline_correction(scans::Vector{MSscan}; method::MethodType=TopHat(100) )\nMSj.tophat_filter(scan::MScontainer, region::Int )\nMSj.tophat_filter(scans::Vector{MSscan}, region::Int )\nMSj.loess(scans::Vector{MSscan}, iter::Int )\nMSj.loess(scan::MScontainer, iter::Int )\nMSj.ipsa(scan::MScontainer, width::Real, maxiter::Int)\nMSj.ipsa(scans::Vector{MSscan}, width::Real, maxiter::Int)","category":"page"},{"location":"reference/#MSj.smooth-Tuple{MSj.MScontainer}","page":"References","title":"MSj.smooth","text":"smooth(scan::MScontainer; method::MethodType=SG(5, 9))\n\nSmooth the intensity of the input data and returns a similar structure.\n\nExamples\n\njulia> smoothed_data = MSj.smooth(scans)\nMSj.MSscans(1, 0.1384, 5.08195e6, [140.083, 140.167, 140.25, 140.333, 140.417, 140.5, 140.583, 140.667, 140.75, 140.833  â€¦  1999.25, 1999.33, 1999.42, ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.smooth-Tuple{Array{MSj.MSscan,1}}","page":"References","title":"MSj.smooth","text":"smooth(scans::Vector{MSscan}; method::MethodType=SG(5, 9, 0))\n\nSmooth the intensity of the input data and returns a similar structure.\n\nExamples\n\njulia> scans = load(\"filename\")\njulia> smoothed_data = MSj.smooth(scans)\n6-element Array{MSj.MSscan,1}:\n MSj.MSscan(1, 0.1384, 5.08195e6 .....\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.savitzky_golay_filtering-Tuple{MSj.MScontainer,Int64,Int64,Int64}","page":"References","title":"MSj.savitzky_golay_filtering","text":"savitzky_golay_filtering(scan::MSj.MScontainer, order::Int, window::Int, deriv::Int)\n\nSavinsky and Golay filtering of mz and int data within the MSscan(s) container.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.centroid-Tuple{MSj.MScontainer}","page":"References","title":"MSj.centroid","text":"centroid(scan::MScontainer; method::MethodType=MethodType=SNRA(1., 100) )\n\nPeak picking algorithm taking a MSscan or MSscans object as input and returning an object of the same type containing the detected peaks.  Available algorithm are : Signal to Noise Ratio (SNR) and Template Based Peak Detection (TBPD). Default method is Signal to Noise Ratio Analysis (SNRA), with default threshold = 1.0 and region = 100.\n\nExamples\n\njulia> centroid(scans)\nMSscans(1, 0.1384, 5.08195e6, [140.083, 140.167, 140.25, 140.333, 140.417, 140.5, 140.583, 140.667, 140.75, 140.833  â€¦  1999.25, 1999.33, 1999.42, ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#Chromatogram-1","page":"References","title":"Chromatogram","text":"","category":"section"},{"location":"reference/#","page":"References","title":"References","text":"","category":"page"},{"location":"reference/#","page":"References","title":"References","text":"No functions yet. To be added.","category":"page"},{"location":"reference/#Simulations-1","page":"References","title":"Simulations","text":"","category":"section"},{"location":"reference/#","page":"References","title":"References","text":"","category":"page"},{"location":"reference/#","page":"References","title":"References","text":"MSj.formula\nMSj.masses\nMSj.isotopic_distribution\nMSj.simulate","category":"page"},{"location":"reference/#MSj.formula","page":"References","title":"MSj.formula","text":"formula(formula::String)\n\nPrivate function that reads the input chemical formula and sorts the atoms. It returns a dictionary in which the different entries represent the atoms and the values are the number of times the atoms have been found in the formula.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MSj.masses","page":"References","title":"MSj.masses","text":"masses(input::String)\n\nCalculates the average, monoistopic and nominal masses for the chemical formula given as an input. The result is returned in a dictionary with the following entries: \"Monoiotopic\", Average\" and \"Nominal\".\n\nExamples\n\njulia> masses(\"C254 H377 N65 O75 S6\")\nDict(\"S\" => 6,\"C\" => 254,\"N\" => 65,\"H\" => 377,\"O\" => 75)\nDict{String,Float64} with 3 entries:\n  \"Monoisotopic\" => 5729.6\n  \"Average\"      => 5733.55\n  \"Nominal\"      => 5727.0\n\n\n\n\n\nmasses(f::Dict{String,Int})\n\nCalculates the average, monoistopic and nominal masses for the chemical formula dictionary, such as prodcued by MSj.formula. The result is returned in a dictionary with the following entries: \"Monoiotopic\", Average\" and \"Nominal\".\n\nExamples\n\njulia> masses(\"C254 H377 N65 O75 S6\")\nDict(\"S\" => 6,\"C\" => 254,\"N\" => 65,\"H\" => 377,\"O\" => 75)\nDict{String,Float64} with 3 entries:\n  \"Monoisotopic\" => 5729.6\n  \"Average\"      => 5733.55\n  \"Nominal\"      => 5727.0\n\n\n\n\n\n","category":"function"},{"location":"reference/#MSj.isotopic_distribution","page":"References","title":"MSj.isotopic_distribution","text":"isotopic_distribution(input::String, p_target::Real; charge::Int = +1, tau::Real = 0.1, Elements::Dict{String,Array{MSj.Isotope,1}} = MSj.Elements)\n\nCalculates the isotopic distribution of input formula for which the overall probabilities equals p_target using the isospec algorithm. The charge state is entered as an optional argument. The peaks detection threshold tau is by default set to 10%.\n\nExamples\n\njulia> isotopic_distribution(\"C254 H377 N65 O75 S6\", 0.5)\nDict(\"S\" => 6,\"C\" => 254,\"N\" => 65,\"H\" => 377,\"O\" => 75)\n9Ã—15 Array{Union{Float64, Int, String},2}:\n     \"Masses\"   \"Probability\"     \"12C\"   \"13C\"   \"32S\"   \"34S\"   \"33S\"   \"36S\"    \"14N\"   \"15N\"    \"16O\"   \"18O\"   \"17O\"     \"1H\"   \"2H\"\n 5731.61       0.112302        252       2       6       0       0       0       65       0       75       0       0       377      0    \n 5732.61       0.102878        251       3       6       0       0       0       65       0       75       0       0       377      0    \n 5730.6        0.0814037       253       1       6       0       0       0       65       0       75       0       0       377      0    \n 5733.61       0.0704028       250       4       6       0       0       0       65       0       75       0       0       377      0    \n 5734.62       0.0383896       249       5       6       0       0       0       65       0       75       0       0       377      0    \n 5733.6        0.0301637       252       2       5       1       0       0       65       0       75       0       0       377      0    \n 5729.6        0.0293871       254       0       6       0       0       0       65       0       75       0       0       377      0    \n 5734.61       0.0276323       251       3       5       1       0       0       65       0       75       0       0       377      0    \n``julia> isotopic_distribution(\"C254 H377 N65 O75 S6\", 0.5, charge = +7)\nDict(\"S\" => 6,\"C\" => 254,\"N\" => 65,\"H\" => 377,\"O\" => 75)\n9Ã—15 Array{Union{Float64, Int, String},2}:\n    \"Masses\"   \"Probability\"     \"12C\"   \"13C\"   \"32S\"   \"34S\"   \"33S\"   \"36S\"    \"14N\"   \"15N\"    \"16O\"   \"18O\"   \"17O\"     \"1H\"   \"2H\"\n 818.801      0.112302        252       2       6       0       0       0       65       0       75       0       0       377      0    \n 818.944      0.102878        251       3       6       0       0       0       65       0       75       0       0       377      0    \n 818.658      0.0814037       253       1       6       0       0       0       65       0       75       0       0       377      0    \n 819.088      0.0704028       250       4       6       0       0       0       65       0       75       0       0       377      0    \n 819.231      0.0383896       249       5       6       0       0       0       65       0       75       0       0       377      0    \n 819.086      0.0301637       252       2       5       1       0       0       65       0       75       0       0       377      0    \n 818.514      0.0293871       254       0       6       0       0       0       65       0       75       0       0       377      0    \n 819.23       0.0276323       251       3       5       1       0       0       65       0       75       0       0       377      0    \n\n\n\n\n\n","category":"function"},{"location":"reference/#MSj.simulate","page":"References","title":"MSj.simulate","text":"simulate(I::Array{Union{Float64, Int, String}}, âˆ†mz::Real; model::Symbol=:gauss, Npoints::Int=1000)\n\nFrom an isotopic distribution and a peak width returns a mass spectrum (MSScan). The number of points of the resulting mass spectrum is passed as an optional argument. Peak shape are :gauss (default), :lorentz, :voight.\n\nExamples\n\njulia>  a = simulate(I, 0.4)\nMSj.MSscan(1, 0.0, 30898.192348114364, [5727.102517458742 ..., \"\", \"\", 0.0)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Plots-1","page":"References","title":"Plots","text":"","category":"section"},{"location":"reference/#","page":"References","title":"References","text":"","category":"page"},{"location":"reference/#","page":"References","title":"References","text":"Modules = [MSj.plots]\n","category":"page"},{"location":"reference/#MSj.plots","page":"References","title":"MSj.plots","text":"Plotting module for MScontainer data type (MSscan, MSscans and Chromatogram).\n\njulia> plot(scans[1])\njulia> plot(chr)\n\n\n\n\n\n","category":"module"},{"location":"reference/#MSj.plots.normalisation-Tuple{MSj.Chromatogram}","page":"References","title":"MSj.plots.normalisation","text":"normalisation(cr::MSj.Chromatogram)\n\nNormalization function for plotting chromatograms in raltive intensity.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.plots.normalisation-Tuple{MSj.MScontainer}","page":"References","title":"MSj.plots.normalisation","text":"normalisation(ms::MSj.MScontainer)\n\nNormalization function for plotting mass spectra in relative intensity.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.plots.scaling-Tuple{MSj.Chromatogram}","page":"References","title":"MSj.plots.scaling","text":"scaling(cr::MSj.Chromatogram)\n\nScaling function to display retention times of chromatograms in minutes instead of seconds.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RecipesBase.apply_recipe-Tuple{Dict{Symbol,Any},MSj.Chromatogram}","page":"References","title":"RecipesBase.apply_recipe","text":"h(cr::MSj.Chromatogram; method = :relative)\n\nAllows plotting directly chromatograms. The defaults relative intensity plotting may be changed by setting method = :absolute.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RecipesBase.apply_recipe-Tuple{Dict{Symbol,Any},MSj.MSscans}","page":"References","title":"RecipesBase.apply_recipe","text":"g(ms::MSj.MSscans; method = :relative)\n\nAllows plotting directly mass spectra MSscans. The defaults relative intensity plotting may be changed by setting method = :absolute.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RecipesBase.apply_recipe-Tuple{Dict{Symbol,Any},MSj.MSscan}","page":"References","title":"RecipesBase.apply_recipe","text":"f(ms::MSscan; method = :relative)\n\nAllows plotting directly mass spectra MSscan. The defaults relative intensity plotting may be changed by setting method = :absolute.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Utilities-1","page":"References","title":"Utilities","text":"","category":"section"},{"location":"reference/#","page":"References","title":"References","text":"","category":"page"},{"location":"reference/#Base-overloaded-1","page":"References","title":"Base overloaded","text":"","category":"section"},{"location":"reference/#","page":"References","title":"References","text":"+(a::MScontainer, b::MScontainer)\n-(a::MScontainer, b::MScontainer)\n/(a::MSscan, N::Real)\n/(a::MSscans, N::Real)\n*(a::MSscan, N::Real)\n*(a::MSscans, N::Real)\n*(N::Real, a::MScontainer)\n*(a::MScontainer, b::MScontainer)","category":"page"},{"location":"reference/#Base.:+-Tuple{MSj.MScontainer,MSj.MScontainer}","page":"References","title":"Base.:+","text":"+(a::MScontainer, b::MScontainer)\n\nAddition of mass spectra elementwise.\n\njulia> scans[1] - scans[2]\nMSj.MSscans([1, 2], [0.1384, 0.7307]\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:--Tuple{MSj.MScontainer,MSj.MScontainer}","page":"References","title":"Base.:-","text":"-(a::MScontainer, b::MScontainer)\n\nSubstraction of mass spectra elementwise. Negative scan num refers the 'b' MScontainer.\n\njulia> a - b\nMSj.MSscans([1, 4], [0.1384, 3.7578, -0.1384, -3.7578]...\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:/-Tuple{MSj.MSscan,Real}","page":"References","title":"Base.:/","text":"/(a::MSscan, N::Real)\n\nDivide the intensity and the tic data of a MSscan by a number.\n\njulia> scans[1] / 1.0e2\nMSj.MSscan(1, 0.1384, 50819.5, [140. ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:/-Tuple{MSj.MSscans,Real}","page":"References","title":"Base.:/","text":"/(a::MSscans, N::Real)\n\nDivide in the intenisty, tic and variance of a MSscans by a number.\n\njulia> a / 1.0e2\nMSj.MSscans(1, 0.1384, 50819.5, [140. ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:*-Tuple{MSj.MSscan,Real}","page":"References","title":"Base.:*","text":"*(a::MSscan, N::Real)\n\nMultiply the intensity and the tic data of a MSscan by a number.\n\njulia> scans[1] * 1.0e2\nMSj.MSscan(1, 0.1384, 50819.5, [140. ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:*-Tuple{MSj.MSscans,Real}","page":"References","title":"Base.:*","text":"*(a::MSscans, N::Real)\n\nMultiply in the intenisty, tic and variance of a MSscans by a number.\n\njulia> a * 1.0e2\nMSj.MSscans(1, 0.1384, 50819.5, [140. ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:*-Tuple{Real,MSj.MScontainer}","page":"References","title":"Base.:*","text":"*(N::Real, a::MScontainer)\n\nCommutation of multiplication of number with MSscontainer.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:*-Tuple{MSj.MScontainer,MSj.MScontainer}","page":"References","title":"Base.:*","text":"*(a::MScontainer, b::MScontainer)\n\nMultiplication of mass spectra elementwise.\n\njulia> a * b\nMSj.MSscans([2, 5], [0.7307, 4.344\n\n\n\n\n\n","category":"method"},{"location":"reference/#Utility-function-1","page":"References","title":"Utility function","text":"","category":"section"},{"location":"reference/#","page":"References","title":"References","text":"MSj.avg(a::MScontainer, b::MScontainer)\nMSj.add_ion_current(x::Vector{Float64}, y::Vector{Float64}, a::Float64, b::Float64)\nMSj.num2pnt(x::Vector{Float64}, val::Real)\nMSj.savitzky_golay(int::AbstractArray, order::Int, window::Int, deriv::Int)\nMSj.extremefilt(input::AbstractArray, minmax::Function, region::Int)\nMSj.morpholaplace(input::AbstractArray, region::Int)\nMSj.morphogradient(input::AbstractArray, region::Int)\nMSj.tophat(input::AbstractArray, region::Int)\nMSj.bottomhat(input::AbstractArray, region::Int) \nMSj.opening(input::AbstractArray, region::Int)\nMSj.closing(input::AbstractArray, region::Int)\nMSj.erosion(input::AbstractArray, region::Int)\nMSj.dilatation(input::AbstractArray, region::Int)\nMSj.convolve(a::AbstractArray, b::AbstractArray)","category":"page"},{"location":"reference/#MSj.avg-Tuple{MSj.MScontainer,MSj.MScontainer}","page":"References","title":"MSj.avg","text":"avg(a::MScontainer, b::MScontainer)\n\nReturns the average of the input mass spectra and compute the variance using an incremental Welford algorithm.\n\njulia> MSj.avg(scans[1], scans[4])\nMSj.MSscans([1, 4], [0.1384, 3.7578], ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.add_ion_current-Tuple{Array{Float64,1},Array{Float64,1},Float64,Float64}","page":"References","title":"MSj.add_ion_current","text":"add_ion_current(x::AbstractArray, y::AbstractArray, a::Real, b::Real)\n\nReturns sum the ion current (int) within the m/z range defined by the a and b input values.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.num2pnt-Tuple{Array{Float64,1},Real}","page":"References","title":"MSj.num2pnt","text":"num2pnt(x::AbstractArray, val::Real)\n\nGeneral purpose utility function used to retrieve the index of an array for which the value is closest to the input.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.savitzky_golay-Tuple{AbstractArray,Int64,Int64,Int64}","page":"References","title":"MSj.savitzky_golay","text":"savitzky_golay(int::AbstractArray, order::Int, window::Int, deriv::Int)\n\nSavinsky and Golay filter removes high frequency noise from data. Parameters:     int::AbstractArray     order::Int   order of the polynomial     window::Int  length of the window, has to be an odd number     deriv::Int   the order of the derivative to be computed. Default = 0 leads to smoothing only.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.extremefilt-Tuple{AbstractArray,Function,Int64}","page":"References","title":"MSj.extremefilt","text":"extremefilt(input::AbstractArray, minmax::Function, region::Int)\n\nReturn the erosion or the dilation of the input over the region, which the size of the structuring element.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.morpholaplace-Tuple{AbstractArray,Int64}","page":"References","title":"MSj.morpholaplace","text":"morpholaplace(input::AbstractArray, region::Int)\n\nPerfoms morphological Laplacian of the input array, as defined by the addition of the dilatation and the erosion of the input array.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.morphogradient-Tuple{AbstractArray,Int64}","page":"References","title":"MSj.morphogradient","text":"morphogradient(input::AbstractArray, region::Int)\n\nPerfoms morphological Gradient of the input array, defined by the difference between the dilatation and the erosion of the input array.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.tophat-Tuple{AbstractArray,Int64}","page":"References","title":"MSj.tophat","text":"tophat(input::AbstractArray, region::Int)\n\nPerforms the Top Hat of the input Array, defined by the difference between the input and its morphological opening.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.bottomhat-Tuple{AbstractArray,Int64}","page":"References","title":"MSj.bottomhat","text":"bottomhat(input::AbstractArray, region::Int)\n\nPerforms the Bottom Hat of the input Array, defined by the difference between the morphological closing of the input and the input.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.opening-Tuple{AbstractArray,Int64}","page":"References","title":"MSj.opening","text":"opening(input::AbstractArray, region::Int)\n\nPerforms the morphological opening of the input Array, which is the dilatation of the erosion of the input\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.closing-Tuple{AbstractArray,Int64}","page":"References","title":"MSj.closing","text":"closing(input::AbstractArray, region::Int\n\nPerforms the morphological closing of the input Array, which is defined as the erosion of the dilatation of the input.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.erosion-Tuple{AbstractArray,Int64}","page":"References","title":"MSj.erosion","text":"erosion(input::AbstractArray, region::Int)\n\nPerforms the morphological erosion of the input, which is the minimum-filtering over the structuring element region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.dilatation-Tuple{AbstractArray,Int64}","page":"References","title":"MSj.dilatation","text":"dilatation(input::AbstractArray, region::Int)\n\nPerforms the morphological dilatation of the input, which is the maximum-filtering over the structuring element region\n\n\n\n\n\n","category":"method"},{"location":"reference/#MSj.convolve-Tuple{AbstractArray,AbstractArray}","page":"References","title":"MSj.convolve","text":"convolve(a::AbstractArray, b::AbstractArray)\n\nConvolve arrays a and b using the Fourier transform algorithm.\n\n\n\n\n\n","category":"method"},{"location":"man/introduction/#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"man/introduction/#","page":"Introduction","title":"Introduction","text":"The MSj package aims at providing an API to the most common file format in mass spectrometry. The following file formats are currently supported:","category":"page"},{"location":"man/introduction/#","page":"Introduction","title":"Introduction","text":"mzXML ","category":"page"},{"location":"tutos/MSj/#The-MSj-package-1","page":"MSj","title":"The MSj package","text":"","category":"section"},{"location":"tutos/MSj/#Loading-and-plotting-mass-spectrometry-data-1","page":"MSj","title":"Loading and plotting mass spectrometry data","text":"","category":"section"},{"location":"tutos/MSj/#","page":"MSj","title":"MSj","text":"This tutorial shows how to use how to import data and how to plot mass spectra.","category":"page"},{"location":"tutos/MSj/#","page":"MSj","title":"MSj","text":"Loading and plotting data","category":"page"},{"location":"tutos/MSj/#Filtering-and-averaging-1","page":"MSj","title":"Filtering and averaging","text":"","category":"section"},{"location":"tutos/MSj/#","page":"MSj","title":"MSj","text":"This notebook shows how to filter and average data.","category":"page"},{"location":"tutos/MSj/#","page":"MSj","title":"MSj","text":"Filtering and averaging data","category":"page"},{"location":"tutos/MSj/#Extracting-data-from-several-files-1","page":"MSj","title":"Extracting data from several files","text":"","category":"section"},{"location":"tutos/MSj/#","page":"MSj","title":"MSj","text":"This tutorial gives an example how to extract UV spectroscpy data from different files containing UV activation at different wavelengths.","category":"page"},{"location":"tutos/MSj/#","page":"MSj","title":"MSj","text":"Extracting data from several files","category":"page"},{"location":"tutos/MSj/#Isotopic-distributions-1","page":"MSj","title":"Isotopic distributions","text":"","category":"section"},{"location":"tutos/MSj/#","page":"MSj","title":"MSj","text":"Here we will calculate the isotopic distribution of a compound, simulate a mass spectrum from that distribution and compare this result to experimental data.","category":"page"},{"location":"tutos/MSj/#","page":"MSj","title":"MSj","text":"Isotopic Distributions","category":"page"},{"location":"tutos/julia/#The-Julia-language-1","page":"The Julia language","title":"The Julia language","text":"","category":"section"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"Julia is an open source programming language designed for scientific and technical computing. This section will give a very brief introduction to the Julia language. ","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"note: Note\nSee also the Julia language home page, the Wikibook introduction to Julia or Julia by example.","category":"page"},{"location":"tutos/julia/#Installation-1","page":"The Julia language","title":"Installation","text":"","category":"section"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"Julia binaries are available for various platforms and can be downloaded here.  Plateform specific instructions may be found here.","category":"page"},{"location":"tutos/julia/#Executing-Julia-code-1","page":"The Julia language","title":"Executing Julia code","text":"","category":"section"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"Julia code can be executed interactively using the REPL as follow:","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"println(\"Hello\")","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"The println(\"Hello\") line can be put in a file, such as hello.jl and executed as a script, which will produce the same output.","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"$ julia hello.jl","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"You can also put #!/usr/local/bin/julia in the first line of the hello.jl file, make it executable (chmod +x hello.jl) and execute it like any other executable.","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"Finally, Julia scripts can be executed within Jupyter Notebooks, see the dedicated section Jupyter notebooks.","category":"page"},{"location":"tutos/julia/#Types-1","page":"The Julia language","title":"Types","text":"","category":"section"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"Julia is a strongly typed language ( see the julia wikibook) In Julia types are organized in a hierarchy with a tree structure. The root of the tree is the Any type.  The Number type is a direct child of Any and possesses two subtypes: Complex and Real. The Real type has four types: Integer, AbstractFloat, Irrational and Rational. The exact number hierarchy is as follow:","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"Number\n â†³ Complex\n â†³ Real\n    â†³ AbstractFloat \n\t   â†³ BigFloat \n\t   â†³ Float64 \n\t   â†³ Float32 \n\t   â†³ Float16\n    â†³ Integer\n\t   â†³ BigInt\n\t   â†³ Bool\n\t   â†³ Signed\n\t      â†³ Int128 \n\t\t  â†³ Int64 \n\t\t  â†³ Int32 \n\t\t  â†³ Int16 \n\t\t  â†³ Int8\n\t   â†³ Unsigned\n\t      â†³ UInt128 \n\t\t  â†³ Int64 \n\t\t  â†³ UInt32 \n\t\t  â†³ UInt16 \n\t\t  â†³ UInt8\n\tâ†³ Irrational\n\tâ†³ Rational","category":"page"},{"location":"tutos/julia/#Creating-vectors-and-matrices-1","page":"The Julia language","title":"Creating vectors and matrices","text":"","category":"section"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"A vector is created as follow","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"A = [1, 2, 3]                  # vector\nA = range(1, 10, step = 2)   # linearly spaced\nA = range(1, 10, length = 5) # linearly spaced\nA = rand(10)                 # random with 10 elements\nj = 2; k = 2; n = 10;\nA = j:k:n                    # from j to n with step size k","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"and similarly for matrices","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"A = [1 2; 3 4]               # matrix\nA = rand(2, 2)               # random 2x2 matrix","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"Vector and matrices can be manipulated as follow:","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"transpose(A)                 # Return the transpose of A\nA[:]                         # Flatten matrix A (convert matrix to vector)\nA[2,2]                       # Accessing element at row 2 and colomun 2\nA[1:4, :]                    # Accessing specific rows 1 to 4","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"Vector and matrix may be preallocated like this:","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"A = rand(5)                  # a vector / matrix\nB = similar(A)               # an emply vector / matrix similar to A","category":"page"},{"location":"tutos/julia/#Operations-1","page":"The Julia language","title":"Operations","text":"","category":"section"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"The following present a few example of operations:","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"julia> dot(A,B)                     # dot product between A and B \njulia> A .* B                       # Element wise multiplication\njulia> A * B                        # Matrix multiplcation\njulia> norm(A)                      # Euclidian norm\njulia> sum(A, dims = 1)             # sum over each column\njulia> sum(A, dims = 2)             # sum over each rows","category":"page"},{"location":"tutos/julia/#Loops-1","page":"The Julia language","title":"Loops","text":"","category":"section"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"A loop in Julia can be done like this:","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"julia> for i in 1:N\njulia>   #do something\njulia> end","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"While loops my be achieved like this:","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"julia> while i <= N\njulia>   #do something\njulia> end","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"and if / else flow like this:","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"julia> if i < N\njulia>   #do something\njulia> else \njulia>   #do something else\njulia> end","category":"page"},{"location":"tutos/julia/#Functions-and-methods-1","page":"The Julia language","title":"Functions and methods","text":"","category":"section"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"A function is defined like this:","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"julia> function f(x)\njulia>   return x^2\njulia> end","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"which can be simplified as:","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"julia> f(x) = x^2","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"Broadcasting a function over a collection or an Array is achieved like this:","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"julia> f(x) = x^2\njulia> x = 1:10\njulia> f.(x)","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"In Julia, functions that modify their arguments are named with an exclamation mark ! at the end of their name, such as:","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"julia> function f!(out, x)\njulia>   out = x.^2\njulia> end\njulia> x = rand(10)\njulia> y = similar(x)\njulia> f!(y, x)","category":"page"},{"location":"tutos/julia/#Importing-and-using-Packages-1","page":"The Julia language","title":"Importing and using Packages","text":"","category":"section"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"The Julia code is organized into files, modules and packages. A file using the .jl extension contains julia code. Related functions and variable may be gathered in modules.  One or more modules may be organized into packages. To use a package, it has to be called like this:","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"julia> using A_package","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"If it is not installed, before being used:","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"julia> using Pkg                      # using the Package manager package\njulia> Pkg.add(\"A_package\")\njulia> using A_package","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"Now every public function which is made available by the package A_package is available directly. Private functions have to be called like this: ","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"julia> a_public_function()                   # Calling a public function\njulia> A_package.a_private_function()        # Calling private functions","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"The same is true for the variables defined in the packages.","category":"page"},{"location":"tutos/julia/#Jupyter-notebooks-1","page":"The Julia language","title":"Jupyter notebooks","text":"","category":"section"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"Jupyter notebooks are web based documents that may contains both codes, figures and other textual elements (such as equations, links, ...).  Jupyter notebook may be installed easily using Julia:","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"julia> using Pkg\njulia> Pkg.add(\"IJulia\")","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"When IJulia is installed, then a notebook may be launch like this:","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"julia> using IJulia\njulia> notebook()","category":"page"},{"location":"tutos/julia/#","page":"The Julia language","title":"The Julia language","text":"The notebook() function should launch a web browser from which a new notebook  may be started. On each entry of the notebook code, Markdown or text may be inserted. Each line of code may be executed and will eventually return a result. In the following, the tutorials are organized in Jupyer notebooks form and can be viewed using nbviewer.","category":"page"},{"location":"man/processing/#Processing-1","page":"Processing","title":"Processing","text":"","category":"section"},{"location":"man/processing/#Smooth-1","page":"Processing","title":"Smooth","text":"","category":"section"},{"location":"man/processing/#","page":"Processing","title":"Processing","text":"The smooth function is public and applies on MSscanor MSscans objects, with an optional method argument set to MSj.SG(5, 9, 0).  Smoothing is performed on the int field using the Savinsky and Golay. The first argument is the order (5 by default), the second is the number of points (default 9)  and the last, is the derivative level (0). The function returns an MScontainer type identical to the input. ","category":"page"},{"location":"man/processing/#Base-line-correction-1","page":"Processing","title":"Base line correction","text":"","category":"section"},{"location":"man/processing/#","page":"Processing","title":"Processing","text":"Base line correction is performed using the baseline_correction function. This function as two methods and operates either on MScontainer or on Array of MSscan such as obtained after importing data.","category":"page"},{"location":"man/processing/#","page":"Processing","title":"Processing","text":"baseline_correction(scans)\nbaseline_correction(scans, method = MSj.IPSA(51, 100))","category":"page"},{"location":"man/processing/#","page":"Processing","title":"Processing","text":"The method argument allows choosing the algorithm. ","category":"page"},{"location":"man/processing/#Top-Hat-1","page":"Processing","title":"Top Hat","text":"","category":"section"},{"location":"man/processing/#","page":"Processing","title":"Processing","text":"This filter is based Top Hat transform used in image processing (wikipedia, Sauve et al. (2004). The region onto which the operation is performed is set using the regionfield of the MSj.TopHat. This filter removes every structure from the input which are smaller in size than the structuring element. Usually a region of 100 points is enough.This filter is fast and works quite well on large and complex backgrounds.","category":"page"},{"location":"man/processing/#Iterative-polynomial-smoothing-algorithm-(IPSA)-1","page":"Processing","title":"Iterative polynomial smoothing algorithm (IPSA)","text":"","category":"section"},{"location":"man/processing/#","page":"Processing","title":"Processing","text":"The default algorithm is the IPSA for iterative polynomial smoothing algorithm (Wang et al. (2017). This iterative algorithm use a zero ordre Savinsly and Golay smoothing to estimate a background. Then a new input, constructed by taking the minimum of either the original spectrum or the background, is smooth again. The process is repeated until the maximum iteration is reached or when the background does not change much. The termination criteria has been changed from the original paper.","category":"page"},{"location":"man/processing/#Locally-weighted-error-sum-of-squares-regression-(LOESS)-1","page":"Processing","title":"Locally weighted error sum of squares regression (LOESS)","text":"","category":"section"},{"location":"man/processing/#","page":"Processing","title":"Processing","text":"The LOESS family of algorithm is based on non-parametric linear local regression where the regression is weighted to reduced the influence of more distant data. We use here the iterative robust estimation procedure where the weights are updated with a bisquare function of the median of the residuals. This algorithm takes the number of iteration to be performed. Usually 3 iteration is enough. This algorithm is slow and is not recommended. The implementation will be improved in future versions.","category":"page"},{"location":"man/processing/#Peak-picking-1","page":"Processing","title":"Peak picking","text":"","category":"section"},{"location":"man/processing/#","page":"Processing","title":"Processing","text":"Pick-picking is performed using the public centroid function. It operates on MSscanor MSscanstype of data and return a similar type. It takes a method argument, set by default to the Signal to Noise Analysis method: MSj.SNRA.","category":"page"},{"location":"man/processing/#","page":"Processing","title":"Processing","text":"centroid(scan)","category":"page"},{"location":"man/processing/#Signal-to-Noise-Ratio-Analysis-(SNRA)-1","page":"Processing","title":"Signal to Noise Ratio Analysis (SNRA)","text":"","category":"section"},{"location":"man/processing/#","page":"Processing","title":"Processing","text":"Signal to noise ratio analysis is a very general approach, which relies on the definition of noise. Here, we use TopHat filter to define the noise. Then the signal to noise ratio is calculated. Peaks are found by searching for a local maximum for which the signal to noise ratio is above the threshold. By defaults the MSj.SNRA uses a threshold = 1.0 and a structuring element of 100 points.","category":"page"},{"location":"man/processing/#","page":"Processing","title":"Processing","text":"centroid(scan, method = MSj.SNRA(1., 100)","category":"page"},{"location":"man/processing/#Threshold-base-peak-detection-algorithm-(TBPD)-1","page":"Processing","title":"Threshold base peak detection algorithm (TBPD)","text":"","category":"section"},{"location":"man/processing/#","page":"Processing","title":"Processing","text":"The TBPD method identifies features based on their similarity (as described by the Pearson correlation coefficient) with a template peak. By default the MSj.TBPD method type uses a Gaussian function, with 1000 mass resolving power and a threshold level set to 0.2% as :","category":"page"},{"location":"man/processing/#","page":"Processing","title":"Processing","text":"centroid(scan, method = MSj.TBPD(:gauss, 1000, 0.2)","category":"page"},{"location":"man/processing/#","page":"Processing","title":"Processing","text":"Two other shape functions are available:","category":"page"},{"location":"man/processing/#","page":"Processing","title":"Processing","text":":loretz which uses a Cauchy-Lorentz function and\n:voigt which implements a pseudo-voigt profile (Ida et al., J. Appl. Cryst. (2000), Wikipedia)","category":"page"},{"location":"man/processing/#","page":"Processing","title":"Processing","text":"The :lorentz profile fits better Fourrier Transform mass spectra. The :voigt shape is the result of the convolution of gaussi and Cauchy-Lorentz shape.","category":"page"},{"location":"man/processing/#","page":"Processing","title":"Processing","text":"centroid(scan, method = MSj.TBPD(:lorentz, 1000., 0.1)\ncentroid(scan, method = MSj.TBPD(:voight,  1000., 0.1)","category":"page"},{"location":"#Home-1","page":"Home","title":"Home","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"MSj.jl is a package for loading, processing and plotting mass spectrometry data. It provides a range of functionalities such as:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Getting information on the file\nLoad a file\nAveraging mass spectra based on various criteria that may be combined\nChromatogram\nProcessing the data\nsmoothing\nbaseline correction\npeak-picking\nCalculation of isotopic distribution","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The tutorial page shows examples how to use this package and provides a general guide to it. The manual page explains the structure of the package and the reference page gives a full documentation for each type and function.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"There are two ways of installing the package.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> using Pkg ;\njulia> Pkg.add(PackageSpec(url=\"https://github.com/ajgiuliani/MSj.jl\"))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"or","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> ]\n(v1.3) pkg>  add https://github.com/ajgiuliani/MSj.jl","category":"page"},{"location":"#Supported-file-format-1","page":"Home","title":"Supported file format","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"mzXML","category":"page"},{"location":"man/types/#Data-types-1","page":"Data types","title":"Data types","text":"","category":"section"},{"location":"man/types/#","page":"Data types","title":"Data types","text":"The main data type of the package is the abstract type MSj.MScontainer.","category":"page"},{"location":"man/types/#","page":"Data types","title":"Data types","text":"Mass spectrometry scans are stored in the following structures, inspired from the mzXML format, which is a subtype of MSj.MScontainer. ","category":"page"},{"location":"man/types/#","page":"Data types","title":"Data types","text":"struct MSscan <: MScontainer\n    num::Int                          # num\n    rt::Float64                       # retentionTime\n    tic::Float64                      # totIonCurrent\n    mz::Vector{Float64}               # m/z\n    int::Vector{Float64}              # intensity\n    level::Int                        # msLevel\n    basePeakMz::Float64               # basePeakMz\n    basePeakIntensity::Float64        # basePeakIntensity\n    precursor::Float64                # precursorMz\n    polarity::String                  # polarity\n    activationMethod::String          # activationMethod\n    collisionEnergy::Float64          # collisionEnergy\nend","category":"page"},{"location":"man/types/#","page":"Data types","title":"Data types","text":"Another subtype, MSj.Chromatogram, is used to store the retention time, the ionic current and the maximum value of the ion current.","category":"page"},{"location":"man/types/#","page":"Data types","title":"Data types","text":"struct Chromatogram  <: MScontainer\n    rt::Vector{Float64}               # araay of retention times\n    ic::Vector{Float64}               # array of ion current\n    maxic::Float64                    # maximum ion current (used in plotting normalization)\nend","category":"page"},{"location":"man/types/#","page":"Data types","title":"Data types","text":"Combination of mass spectra requires another subtype of MSj.MScontainer called MSj.MSscans (notice the ending s).","category":"page"},{"location":"man/types/#","page":"Data types","title":"Data types","text":"struct MSscans  <: MScontainer\n    num::Vector{Int}                  # num\n    rt::Vector{Float64}               # retentionTime\n    tic::Float64                      # totIonCurrent\n    mz::Vector{Float64}               # m/z\n    int::Vector{Float64}              # intensity\n    level::Vector{Int}                # msLevel\n    basePeakMz::Float64               # basePeakMz\n    basePeakIntensity::Float64        # basePeakIntensity\n    precursor::Vector{Float64}        # precursorMz\n    polarity::Vector{String}          # polarity\n    activationMethod::Vector{String}  # activationMethod\n    collisionEnergy::Vector{Float64}  # collisionEnergy\n    s::Vector{Float64}                # variance\nend","category":"page"},{"location":"man/types/#","page":"Data types","title":"Data types","text":"The MSj.MSscans structure is very similar to the MSj.MSscan one, except that the fields num, rt, precursor, polarity, activationMethod and collisionEnergy are vectors. The idea is to keep track of the history of the operations that have led to this result. For example, if a MSscans element is the result of the addition of two individual scans such as scans[1] + scans[2], then the numfield of resulting MSscans is an array [1, 2]. The same applies to the retention time, precursor m/z, polarity, activation method and collision energy fields.","category":"page"}]
}
