var documenterSearchIndex = {"docs":
[{"location":"misc/#Miscellaneous-1","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"misc/#Logo-1","page":"Miscellaneous","title":"Logo","text":"","category":"section"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"page"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"Code used to generate the msJlogo. ","category":"page"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"using Plots\ngr()\n\n@. model(x, p) = p[4] + p[3] * exp(- ( (x-p[2])/p[1] )^2)\n\nx1 = range(-7.5, stop=-2.5, length=100)\np1 = [1, -5, 1, 0]\ny1 = model(x1,p1);\nplot(x1,y1, color = RGBA(0.884, 0.2, 0.2), fillrange = 0, fillalpha = 0.9, label = \"\", \n\tthickness_scaling = 2.0, \n    xaxis=nothing,\n    yaxis=nothing,\n    background_color=:transparent, foreground_color=:black,)\n\nx2 = range(-2.5, stop=2.5, length=100)\np2 = [1, 0, 2, 0]\ny2 = model(x2, p2)\nplot!(x2,y2, color= RGBA(0.22, 0.596, 0.149), fillrange = 0, fillalpha = 0.9, label = \"\")\n\nx3 = range(2.5, stop=7.5, length=100)\np3 = [1, 5, 1, 0]\ny3 = model(x3,p3)\nplot!(x3,y3,color = RGBA(0.584, 0.345, 0.608), fillrange = 0, fillalpha = 0.9, label = \"\")\n\nx4 = range(-17.5, stop=-12.5, length=100)\np4 = [1, -15, 1, 0]\ny4 = model(x4,p4);\nplot!(x4,y4, color = RGBA(0.255, 0.412, 0.882), fillrange = 0, fillalpha = 0.9, label = \"\")\n\nsavefig(\"docs/src/assets/logo.png\")","category":"page"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"(Image: logo)","category":"page"},{"location":"manual/#Manual-1","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Introduction-1","page":"Manual","title":"Introduction","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The msJ package aims at providing an API to the most common file format in mass spectrometry. The following file formats are currently supported:","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"mzXML ","category":"page"},{"location":"manual/#Public-elements-1","page":"Manual","title":"Public elements","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The functions below are exported:","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"info \nload \nchromatogram\naverage\nextract\ncentroid\nsmooth\nbaseline_correction","category":"page"},{"location":"manual/#Data-types-1","page":"Manual","title":"Data types","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The main data type of the package is the abstract type msJ.MScontainer.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Mass spectrometry scans are stored in the following structures, inspired from the mzXML format, which is a subtype of msJ.MScontainer. ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"struct MSscan <: MScontainer\n    num::Int                          # num\n    rt::Float64                       # retentionTime\n    tic::Float64                      # totIonCurrent\n    mz::Vector{Float64}               # m/z\n    int::Vector{Float64}              # intensity\n    level::Int                        # msLevel\n    basePeakMz::Float64               # basePeakMz\n    basePeakIntensity::Float64        # basePeakIntensity\n    precursor::Float64                # precursorMz\n    polarity::String                  # polarity\n    activationMethod::String          # activationMethod\n    collisionEnergy::Float64          # collisionEnergy\nend","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Another subtype, msJ.Chromatogram, is used to store the retention time, the ionic current and the maximum value of the ion current.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"struct Chromatogram  <: MScontainer\n    rt::Vector{Float64}               # araay of retention times\n    ic::Vector{Float64}               # array of ion current\n    maxic::Float64                    # maximum ion current (used in plotting normalization)\nend","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Combination of mass spectra requires another subtype of msJ.MScontainer called msJ.MSscans (notice the ending s).","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"struct MSscans  <: MScontainer\n    num::Vector{Int}                  # num\n    rt::Vector{Float64}               # retentionTime\n    tic::Float64                      # totIonCurrent\n    mz::Vector{Float64}               # m/z\n    int::Vector{Float64}              # intensity\n    level::Vector{Int}                # msLevel\n    basePeakMz::Float64               # basePeakMz\n    basePeakIntensity::Float64        # basePeakIntensity\n    precursor::Vector{Float64}        # precursorMz\n    polarity::Vector{String}          # polarity\n    activationMethod::Vector{String}  # activationMethod\n    collisionEnergy::Vector{Float64}  # collisionEnergy\n    s::Vector{Float64}                # variance\nend","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The msJ.MSscans structure is very similar to the msJ.MSscan one, except that the fields num, rt, precursor, polarity, activationMethod and collisionEnergy are vectors. The idea is to keep track of the history of the operations that have led to this result. For example, if a MSscans element is the result of the addition of two individual scans such as scans[1] + scans[2], then the numfield of resulting MSscans is an array [1, 2]. The same applies to the retention time, precursor m/z, polarity, activation method and collision energy fields.","category":"page"},{"location":"manual/#Information-1","page":"Manual","title":"Information","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The info public function reads the content of a file, but without loading the mass spectrometry data, and returns a Vector{String}containing the number of scans, scans level and for MS/MS data, the precursor m/z, the activation method and energy. Additional information may be gained by setting verbose = true.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"info(filename)\n4-element Array{String,1}:\n \"51 scans\"\n \"MS1+\"\n \"MS2+ 1255.5  CID(CE=18)\"\n \"MS3+ 902.33  PQD(CE=35)\"","category":"page"},{"location":"manual/#Importing-data-1","page":"Manual","title":"Importing data","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"When loading a file containing more than a single acquisition, the individual mass spectrometry scans are pushed into an array of msJ.MSscan.  The individual scans may be retrieve from the array the usual way:","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"julia> scans = load(\"filename\")\n51-element Array{msJ.MSscan,1}:\n msJ.MSscan(1, 0.1384, 5.08195e6, [140.083, 140.167, 140.25, 140.333, 140.417, 140.5, 140.583, 140.667, 140.75, 140.833  …  1999.25, 1999.33, 1999.42, ....)\n...\n\njulia> scans[1]\nmsJ.MSscan(1, 0.1384, 5.08195e6, [140.083, 140.167, 140.25, 140.333, 140.417, 140.5, 140.583, 140.667, 140.75, 140.833  …  1999.25, 1999.33, 1999.42, ....)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"As mentioned above, chromatograms may be retrieved from a file and imported in msJ.Chromatogram :","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"julia> chromatogram(\"filename\")\nmsJ.Chromatogram([0.1384, 0.7307, 2.1379, 3.7578, 4.3442, 5.7689], [5.08195e6, 9727.2, 11.3032, 4.8084e6, 12203.5, 4.84455], 5.08195e6)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The function msJ.retention_time reads the retention time of an input file and returns a Vector{Float64}containing the time in seconds.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"julia> msJ.retention_time(\"filename\")\n51-element Array{Float64,1}:\n  0.1384\n  0.7307\n  2.1379\n....msJ.FilterType\n","category":"page"},{"location":"manual/#Exporting-data-1","page":"Manual","title":"Exporting data","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"note: Note\nThis feature is currently under development. ","category":"page"},{"location":"manual/#Combining-and-filtering-data-1","page":"Manual","title":"Combining and filtering data","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/#Average-1","page":"Manual","title":"Average","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The average returns the average of the mass spectra directly from a Vector{MSscan} after Importing data data or directly from the filename.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"julia> average(\"filename\")\nmsJ.MSscans([1, 2, 3 ....\n\njulia> scans = load(\"filename\")\n51-element Array{msJ.MSscan,1}:\n msJ.MSscan(1, 0.1384, 5.08195e6, [140.083, 140.167, 140.25, 140.333, 140.417, 140.5, 140.583, 140.667, 140.75, 140.833  …  1999.25, 1999.33, 1999.42, ....)\n...\n\njulia> average(scans)\nmsJ.MSscans([1, 2, 3 ....\n","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Operating on files takes more time than working on Vector{MSscan} but may be useful to reduce the memory load.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Without any argument the average function averages the entire content of the data and the chromatogram function operates on also on the entire data.","category":"page"},{"location":"manual/#Filtering-1","page":"Manual","title":"Filtering","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The average and chromatogram functions may takes arguments to select specific fields of interest within the data and operate on them. The argument belongs to the msJ.FilterType. Their properties are listed below:","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"FilterType Description Arguments Specificity\nmsJ.Scan Scan num Int, Vector{Int} average, chromatogram\nmsJ.Level MS level Int, Vector{Int} average, chromatogram\nmsJ.Polarity Polarity String, Vector{String} average, chromatogram\nmsJ.Activation_Method Activation method String, Vector{String} average, chromatogram\nmsJ.Activation_Energy Activation energy Real, Vector{Real} average, chromatogram\nmsJ.Precursor Precursor m/z Real, Vector{Real} average, chromatogram\nmsJ.RT Retention time Real, Vector{Real}, Vector{Vector{Real}} average\nmsJ.IC Ion current Vector{Real} average","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"note: Note\nThe filtering function goes first through all the arguments and setup an array of scan num that matches the conditions. Then it uses this array to calculate the average mass spectrum.  So this procedure needs two passes through the data, which is not very efficient. This is a point to make better in the future.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"When the argument is restricted to a single value, such as msJ.Scan(1), filtering is performed on that specific value. If the argument is a vector then filtering involves all the values within the range.  Filtering on msJ.scan([1,10]) means that the result will be obtained for scans ranging from 1 to 10.  The same applies for all FilterType with the exception of msJ.∆MZ, for which the first value of the vector represents the mz and the second value represents the spread ∆mz, so that filtering is operated for all mz value in the range [m/z - ∆mz , m/z + ∆mz].  The msJ.RT type may take a vector or vectors as argument, such `msJ.RT([ [1,10], [20, 30] ]).  In that case, mass spectra will be averaged in [1,10] and [20,30] range.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"These filters may be combined together if necessary. For example, the input below returns the average mass spectrum for:","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"the MS2 scans (level = 2), \nprecursor m/z 1255.5, \nupon CID activation conditions\nwith an activation energy of 18 \nand for retention times in the 1 to 60 s range.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"average(\"filename\", msJ.Precursor(1255.5),\n                    msJ.Activation_Energy(18),\n                    msJ.Activation_Method(\"CID\"),\n                    msJ.Level(2),\n                    msJ.RT( [1, 60] ),\n                    )","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Several filter types may also be combined for chromatograms:","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"chromatogram(\"filename\", msJ.Precursor(1255.5),\n                         msJ.Activation_Energy(18),\n                         msJ.Activation_Method(\"CID\"),\n                         msJ.Level(2),\n                         )","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"If the condition does not match any existing data, then an ErrorException is returned with the \"No matching spectra.\" message.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The chromatogram function has some methods using msJ.MethodType arguments:","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"MethodType Description Arguments Remark\nmsJ.TIC Total ion current None Default\nmsJ.BasePeak Base peak intensity None \nmsJ.MZ m/z range Vector{Real} \nmsJ.∆MZ m/z ± ∆mz Vector{Real} ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"These types control the way chromatograms are calculated: either using the total ionic current, the base peak intensity or using a m/z range.  The method argument of the msJ.chromatogramfunction is set to msJ.TIC() by default. This setting may be overruled by setting the method to desired value:","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"chromatogram(\"filename\", method = msJ.BasePeak())\nchromatogram(\"filename\", method = msJ.MZ( [257, 259] ) ) \nchromatogram(\"filename\", method = msJ.∆MZ( [258, 1] ) ) ","category":"page"},{"location":"manual/#Extracting-subsets-1","page":"Manual","title":"Extracting subsets","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The extract returns a Vector of MSscanfrom either a file of from a Vector{MSscan} following a 'load' command, which corresponds to the filter conditions. See the filtering part above.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"sub_set = extract(\"filename\")                       # extracting without any conditions returns a vector identical to the output \nsub_set = extract(\"filename\", msJ.Level(2) )        # extract MS/MS spectra\nscans = load(\"test.mzxml\")                          # load mass spectra\nsub_set = extract(scans)                            # extract a sub_set without conditions returns the original data","category":"page"},{"location":"manual/#Processing-1","page":"Manual","title":"Processing","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/#Smooth-1","page":"Manual","title":"Smooth","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The smooth function is public and applies on MSscanor MSscans objects, with an optional method argument set to msJ.SG(5, 9, 0).  Smoothing is performed on the int field using the Savinsky and Golay. The first argument is the order (5 by default), the second is the number of points (default 9)  and the last, is the derivative level (0). The function returns an MScontainer type identical to the input. ","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Other smoothing algorithms will be implemented in the future.","category":"page"},{"location":"manual/#Base-line-correction-1","page":"Manual","title":"Base line correction","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Base line correction is performed using the baseline_correction function. This function as two methods and operates either on MScontainer or on Array of MSscan such as obtained after importing data.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"baseline_correction(scans)\nbaseline_correction(scans, method = msJ.IPSA(51, 100))","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The method argument allows choosing the algorithm. ","category":"page"},{"location":"manual/#Top-Hat-1","page":"Manual","title":"Top Hat","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"This filter is based Top Hat transform used in image processing (wikipedia, Sauve et al. (2004). The region onto which the operation is performed is set using the regionfield of the msJ.TopHat. This filter removes every structure from the input which are smaller in size than the structuring element. Usually a region of 100 points is enough.This filter is fast and works quite well on large and complex backgrounds.","category":"page"},{"location":"manual/#Iterative-polynomial-smoothing-algorithm-(IPSA)-1","page":"Manual","title":"Iterative polynomial smoothing algorithm (IPSA)","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The default algorithm is the IPSA for iterative polynomial smoothing algorithm (Wang et al. (2017). This iterative algorithm use a zero ordre Savinsly and Golay smoothing to estimate a background. Then a new input, constructed by taking the minimum of either the original spectrum or the background, is smooth again. The process is repeated until the maximum iteration is reached or when the background does not change much. The termination criteria has been changed from the original paper.","category":"page"},{"location":"manual/#Locally-weighted-error-sum-of-squares-regression-(LOESS)-1","page":"Manual","title":"Locally weighted error sum of squares regression (LOESS)","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The LOESS family of algorithm is based on non-parametric linear local regression where the regression is weighted to reduced the influence of more distant data. We use here the iterative robust estimation procedure where the weights are updated with a bisquare function of the median of the residuals. This algorithm takes the number of iteration to be performed. Usually 3 iteration is enough. This algorithm is slow and is not recommended. The implementation will be improved in future versions.","category":"page"},{"location":"manual/#Peak-picking-1","page":"Manual","title":"Peak picking","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Pick-picking is performed using the public centroid function. It operates on MSscanor MSscanstype of data and return a similar type. It takes a method argument, set by default to the Signal to Noise Analysis method: msJ.SNRA.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"centroid(scan)","category":"page"},{"location":"manual/#Signal-to-Noise-Ratio-Analysis-(SNRA)-1","page":"Manual","title":"Signal to Noise Ratio Analysis (SNRA)","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Signal to noise ratio analysis is a very general approach, which relies on the definition of noise. Here, we use TopHat filter to define the noise. Then the signal to noise ratio is calculated. Peaks are found by searching for a local maximum for which the signal to noise ratio is above the threshold. By defaults the msJ.SNRA uses a threshold = 1.0 and a structuring element of 100 points.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"centroid(scan, method = msJ.SNRA(1., 100)","category":"page"},{"location":"manual/#Threshold-base-peak-detection-algorithm-(TBPD)-1","page":"Manual","title":"Threshold base peak detection algorithm (TBPD)","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The TBPD method identifies features based on their similarity (as described by the Pearson correlation coefficient) with a template peak. By default the msJ.TBPD method type uses a Gaussian function, with 1000 mass resolving power and a threshold level set to 0.2% as :","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"centroid(scan, method = msJ.TBPD(:gauss, 1000, 0.2)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Two other shape functions are available:","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":":loretz which uses a Cauchy-Lorentz function and\n:voigt which implements a pseudo-voigt profile (Ida et al., J. Appl. Cryst. (2000), Wikipedia)","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"The :lorentz profile fits better Fourrier Transform mass spectra. The :voigt shape is the result of the convolution of gaussi and Cauchy-Lorentz shape.","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"centroid(scan, method = msJ.TBPD(:lorentz, 1000., 0.1)\ncentroid(scan, method = msJ.TBPD(:voight,  1000., 0.1)","category":"page"},{"location":"manual/#Plotting-1","page":"Manual","title":"Plotting","text":"","category":"section"},{"location":"manual/#","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"Plotting facilities are available as a submodule to the msJ package.  The msJ.plots module relies on the RecipesBase package, which allows writing recipes to plot users' data types. Hence, recipes have been created for MSscan, Msscans and Chromatogram:","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"plot(scans[1], method = :relative))\n","category":"page"},{"location":"manual/#","page":"Manual","title":"Manual","text":"By default plotting is made in relative intensities, which may be changed by setting method to :absolute.","category":"page"},{"location":"reference/#References-1","page":"Reference","title":"References","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"msJ.builoto","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"CurrentModule = msJ\nDocTestSetup  = quote\n    using LightXML\nend","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"This page lists all the documented elements of the msJ.jl package covering all modules and submodules.","category":"page"},{"location":"reference/#Contents-1","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Main-module-1","page":"Reference","title":"Main module","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"msJ","category":"page"},{"location":"reference/#msJ.msJ","page":"Reference","title":"msJ.msJ","text":"Main module for msJ.jl– A Julia package to load and process mass spectrometry data.\n\n\n\n\n\n","category":"module"},{"location":"reference/#Types-1","page":"Reference","title":"Types","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Submodule with types and structures used to stored the data and dispatch to the right methods.","category":"page"},{"location":"reference/#Data-types-1","page":"Reference","title":"Data types","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"msJ.MScontainer\nmsJ.MSscan\nmsJ.MSscans\nmsJ.Chromatogram","category":"page"},{"location":"reference/#msJ.MScontainer","page":"Reference","title":"msJ.MScontainer","text":"abstract type MScontainer  end\n\nAbstract type containing any imported data belongs to the MScontainer type.\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.MSscan","page":"Reference","title":"msJ.MSscan","text":"struct MSscan <: MScontainer\n\nData structure used to store individual mass spectrometry scans organized following the structure of mzXML files.\n\nstruct MSscan <: MScontainer     num::Int                          # num     rt::Float64                       # retentionTime     tic::Float64                      # totIonCurrent     mz::Vector{Float64}               # m/z     int::Vector{Float64}              # intensity     level::Int                        # msLevel     basePeakMz::Float64               # basePeakMz     basePeakIntensity::Float64        # basePeakIntensity     precursor::Float64                # precursorMz     polarity::String                  # polarity     activationMethod::String          # activationMethod     collisionEnergy::Float64          # collisionEnergy end\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.MSscans","page":"Reference","title":"msJ.MSscans","text":"struct MSscans  <: MScontainer\n\nData structure designed to store mass spectra obtained after filtering operation along with the history of these operation.\n\nstruct MSscans  <: MScontainer     num::Vector{Int}                  # num     rt::Vector{Float64}               # retentionTime     tic::Float64                      # totIonCurrent     mz::Vector{Float64}               # m/z     int::Vector{Float64}              # intensity     level::Vector{Int}                # msLevel     basePeakMz::Float64               # basePeakMz     basePeakIntensity::Float64        # basePeakIntensity     precursor::Vector{Float64}        # precursorMz     polarity::Vector{String}          # polarity     activationMethod::Vector{String}  # activationMethod     collisionEnergy::Vector{Float64}  # collisionEnergy     s::Vector{Float64}                # variance end\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.Chromatogram","page":"Reference","title":"msJ.Chromatogram","text":"struct Chromatogram  <: MScontainer\n\nData structure used to retrieve chromatography data.\n\nstruct Chromatogram  <: MScontainer     rt::Vector{Float64}     ic::Vector{Float64}     maxic::Float64 end\n\n\n\n\n\n","category":"type"},{"location":"reference/#Methods-Types-1","page":"Reference","title":"Methods Types","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"msJ.MethodType\nmsJ.BasePeak\nmsJ.TIC\nmsJ.∆MZ\nmsJ.MZ\nmsJ.SG\nmsJ.TBPD\nmsJ.SNRA\nmsJ.TopHat\nmsJ.LOESS\nmsJ.IPSA","category":"page"},{"location":"reference/#msJ.MethodType","page":"Reference","title":"msJ.MethodType","text":"abstract type MethodType  end\n\nType containing all the methods used for filtering the data.\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.BasePeak","page":"Reference","title":"msJ.BasePeak","text":"struct BasePeak <: MethodType\n\nStructure for multiple dispatching to retrieve base peak chromatogram.\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.TIC","page":"Reference","title":"msJ.TIC","text":"struct TIC <: MethodType\n\nDispatching to retrieve total ion current chromatogram.\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.∆MZ","page":"Reference","title":"msJ.∆MZ","text":"struct ∆MZ{argT <: Union{Real, AbstractVector{<:Real} }} <: MethodType\n\nStructure for multiple dispatching to retrieve extracted ion current chromatogram around an m/z ± ∆mz value given by arg = [mz, ∆mz]\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.MZ","page":"Reference","title":"msJ.MZ","text":"struct MZ{argT <: Union{Real, AbstractVector{<:Real} }} <: MethodType\n\nStructure for multiple dispatching to retrieve extracted ion current chromatogram around for m/z in the range arg = [mz1, mz2].\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.SG","page":"Reference","title":"msJ.SG","text":"struct SG{argT <: Int} <: MethodType   #Savinsky & Golay filtering\n\nStructure for multiple dispatching to Savinsky & Golay filtering, providing the order, window size and derivative to be performed.  Defaults values are provided in functions calls.\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.TBPD","page":"Reference","title":"msJ.TBPD","text":"struct TBPD{argT1 <: Symbol, argT2 <: Real}  <: MethodType\n\nStructure for multiple dispatching to Template Base Peak Detection centroiding, providing the shape of the template function, the resolution and threshold.  Defaults values are provided in functions calls.\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.SNRA","page":"Reference","title":"msJ.SNRA","text":"struct SNRA{argT1 <: Real, argT2 <: Int}  <: MethodType\n\nStructure for multiple dispatching to Signal to Noise Ratio Analysis centroiding, providing the threshold value and the size of the region.  Defaults values are provided in functions calls.\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.TopHat","page":"Reference","title":"msJ.TopHat","text":"TopHat{argT <: Int} <: MethodType\n\nStructure for multiple dispatching to TopHat baseline correction. Region is used specify the dimention over which this operation performed\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.LOESS","page":"Reference","title":"msJ.LOESS","text":"LOESS{argT <: Int} <: MethodType\n\nStructure for multiple dispatching to LOcally Weighted Error Sum of Squares regression (LOESS) baseline correction.\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.IPSA","page":"Reference","title":"msJ.IPSA","text":"struct IPSA{argT1 <: Int, argT2 <: Real} <: MethodType\n\nStructure for multiple dispatching to iterative polynomial smoothing algorithm (IPSA) baseline correction.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Filters-1","page":"Reference","title":"Filters","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"msJ.FilterType\nmsJ.RT\nmsJ.IC\nmsJ.Level\nmsJ.Scan\nmsJ.Polarity\nmsJ.Activation_Method\nmsJ.Activation_Energy\nmsJ.Precursor","category":"page"},{"location":"reference/#msJ.FilterType","page":"Reference","title":"msJ.FilterType","text":"abstract type FilterType end\n\nThis type contains  the structures for filtering the data.\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.RT","page":"Reference","title":"msJ.RT","text":"RT{argT <: Union{Real, AbstractVector{<:Real},  AbstractVector{<:AbstractVector{<:Real}} }}\n\nThis type contains  the structures for filtering the data.\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.IC","page":"Reference","title":"msJ.IC","text":"struct IC{argT <: Union{Real, AbstractVector{<:Real} }} <: FilterType\n\nUsed for multiple dispatching to Template Base Peak Detection centroiding, providing the shape of the template function, the resolution and threshold.  Defaults values are provided in functions calls.\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.Level","page":"Reference","title":"msJ.Level","text":"struct Level{argT <: Union{Int, AbstractVector{<:Int} }} <: FilterType\n\nUsed to dispatch filters to MS level.\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.Scan","page":"Reference","title":"msJ.Scan","text":" Scan{argT <: Union{Int, AbstractVector{<:Int} }} <: FilterType\n\nDispatch filter to scan num.\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.Polarity","page":"Reference","title":"msJ.Polarity","text":"struct Polarity{argT <: Union{String, AbstractVector{<:String} }} <: FilterType\n\nDispatch filter to polarity.\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.Activation_Method","page":"Reference","title":"msJ.Activation_Method","text":"struct Activation_Method{argT <: Union{String, AbstractVector{<:String} }} <: FilterType\n\nDispatch filter to activation methods\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.Activation_Energy","page":"Reference","title":"msJ.Activation_Energy","text":"struct Activation_Energy{argT <: Union{Real, AbstractVector{<:Real} }} <: FilterType\n\nDispatch filter to activation energies.\n\n\n\n\n\n","category":"type"},{"location":"reference/#msJ.Precursor","page":"Reference","title":"msJ.Precursor","text":"struct Precursor{argT <: Union{Real, AbstractVector{<:Real} }} <: FilterType\n\nDispatch filter to precursor.\n\n\n\n\n\n","category":"type"},{"location":"reference/#I/O-1","page":"Reference","title":"I/O","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Module for importing and exporting data. Dispatch to specific methods according to the file extension","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"msJ.info(filename::String; verbose::Bool = false)\nmsJ.load(filename::String)\nmsJ.retention_time(filename::String)\nmsJ.chromatogram(filename::String, filters::FilterType...; method::MethodType=TIC())\nmsJ.average(filename::String, arguments::FilterType...; stats::Bool=true)","category":"page"},{"location":"reference/#msJ.info-Tuple{String}","page":"Reference","title":"msJ.info","text":"info(filename::String, verbose::Bool = false)\n\nThe function looks into an file and returns in an Array{String} containing the number of scans and the different scans described by their MS level, polarity and eventually the precursor m/z followed by the activation method and collision energy. Each entry is unique, which gives a summary of the input file. With verbose = true, the functions also returns the parentFile, msManufacturer, msModel, msIonisation, msMassAnalyzer, msDetector, software and dataProcessing if existing.\n\nExample\n\njulia> msJ.info(\"test1.mzXML\")\n4-element Array{String,1}:\n \"51 scans\"               \n \"MS1+\"                   \n \"MS2+ 1255.5  CID(CE=18)\"\n \"MS3+ 902.33  PQD(CE=35)\"\njulia> msJ.info(\"test1.mzXML\", verbose = true)\n12-element Array{String,1}:\n \"parentFile: test1_msJ_1.raw\"\n \"msManufacturer: Thermo Finnigan\"\n \"msModel: LTQ XL\"      \n \"msIonisation: ESI\"\n \"msMassAnalyzer: ITMS\"\n \"msDetector: unknown\"\n \"software: Xcalibur, 2.6.0 SP3\"\n \"dataProcessing: conversion, ReAdW 4.3.1(build Sep  9 2009 12:30:29)\"\n \"51 scans\"\n \"MS1+\"\n \"MS2+ 1255.5  CID(CE=18)\"\n \"MS3+ 902.33  PQD(CE=35)\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.load-Tuple{String}","page":"Reference","title":"msJ.load","text":"function load(filename::String)\n\nChecks the file extension and calls the right function to load the mass spectra if it exists. Returns an array of msJ.MSscan where the individual mass spectra are stored. \n\nExamples\n\njulia> scans = msJ.load(\"test.mzXML\")\n51-element Array{msJ.MSscan,1}:\n msJ.MSscan(1, 0.1384, 5.08195e6, [140.083, 140.167, 140.25, 140.333, 140.417, 140.5, 140.583, 140.667, 140.75, 140.833  …  1999.25, 1999.33, 1999.42, ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.retention_time-Tuple{String}","page":"Reference","title":"msJ.retention_time","text":"retention_time(filename::String)\n\nReturns an array composed of the retention times of the individual mass spectra. \n\nExamples\n\njulia> msJ.retention_time(\"test.mzXML\")\n51-element Array{Float64,1}:\n  0.1384\n  0.7307\n  2.1379\n....\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.chromatogram-Tuple{String,Vararg{msJ.FilterType,N} where N}","page":"Reference","title":"msJ.chromatogram","text":"chromatogram(filename::String, filters::FilterType...; method::MethodType=TIC())\n\nReturns a structure holding the retention time (rt),  the ion current (ic) and the maximum value (maxic) for all the mass spectra within the file. Alternatively, other options may be supplied such as method = msJ.BasePeak, which returns the base peak intensity, method = msJ.∆MZ([500,5]), which returns the ion current for the range mz = 500 ± 5, or method = msJ.MZ([200,1000]) which return the ion current in the range from m/z 200 to m/z 1000.  The data may be filtered by ms level, precursor mass, activation methods, etc, using the arguments msJ.Level(N), msJ.Precursor(mz), msJ.Activation_Method(\"method\")...\n\nExamples\n\njulia> rt, ic = msJ.chromatogram(\"test.mzxml\")\n([0.1384  …  60.4793], [4.74795e6  …  17.4918])\njulia> rt, ic = msJ.chromatogram(\"test.mzxml\", method = msJ.BasePeak() )\n([0.1384  …  60.4793], [102558.0  …  1.23181])\njulia> rt, ic = msJ.chromatogram(\"test.mzxml\", method = msJ.∆MZ([500,5]) )\n([0.1384  …  60.4793], [46036.6  …  14.2529])\njulia> rt, ic = msJ.chromatogram(\"test.mzxml\", method = msJ.MZ([200,1000]))\n([0.1384  …  60.4793], [4.74795e6  …  17.4918])\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.average-Tuple{String,Vararg{msJ.FilterType,N} where N}","page":"Reference","title":"msJ.average","text":"average(filename::String, arguments::FilterType...; stats::Bool=true)\n\nReturns the average mass spectrum container (MSscans) along with the sample standard deviation of the intensities with stats=true (default) for all the mass spectra within file. The data may be filtered by level, precursor mass, activation methods, etc, using the arguments msJ.Level(N), msJ.Precursor(mz), msJ.Activation_Method(\"method\"), or any combination of these arguments.\n\nExamples\n\njulia> spectrum = msfilter(\"test.mzxml\")\nmsJ.MSscans([1, 2, 3 ....\njulia> spectrum = msfilter(\"test.mzxml\", msJ.Level(1) )\nmsJ.MSscans([1, 4, 7, 10,\njulia> spectrum = msfilter(\"test.mzxml\", msJ.Precursor(1255.5) )\nmsJ.MSscans([2, 5, 8, 11, ...\njulia> spectrum = msfilter(\"test.mzxml\", msJ.Activation_Method(\"PQD\") )\nmsJ.MSscans([3, 6, 9, 12, 15,\njulia> spectrum = msfilter(\"test.mzxml\", msJ.Activation_Method(\"PQD\"), msJ.Polarity(\"+\"), msJ.RT([10,20]))\nmsJ.MSscans([9, 12, 15, 18], ...\n\n\n\n\n\n","category":"method"},{"location":"reference/#mzXML-1","page":"Reference","title":"mzXML","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Interface to the mzxml file format","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"msJ.info_mzxml\nmsJ.load_mzxml_all\nmsJ.load_mzxml\nmsJ.load_mzxml_spectrum\nmsJ.retention_time(msRun::XMLElement)\nmsJ.filter(msRun::XMLElement, argument::Level{<:Int})\nmsJ.filter(msRun::XMLElement, argument::Level{<:AbstractVector})\nmsJ.filter(msRun::XMLElement, argument::Scan{<:Int})\nmsJ.filter(msRun::XMLElement, argument::Scan{<:AbstractVector})\nmsJ.filter(msRun::XMLElement, argument::Polarity{<:String})\nmsJ.filter(msRun::XMLElement, argument::Polarity{<:AbstractVector})\nmsJ.filter(msRun::XMLElement, argument::RT{<:Real})\nmsJ.filter(msRun::XMLElement, argument::RT{<:AbstractVector})\nmsJ.filter(msRun::XMLElement, argument::RT{<:AbstractVector{<:AbstractVector} } )\nmsJ.filter(msRun::XMLElement, argument::IC{<:AbstractVector})\nmsJ.filter(msRun::XMLElement, argument::Precursor{<:Real})\nmsJ.filter(msRun::XMLElement, argument::Precursor{<:AbstractVector})\nmsJ.filter(msRun::XMLElement, argument::Activation_Energy{<:Real})\nmsJ.filter(msRun::XMLElement, argument::Activation_Energy{<:AbstractVector})\nmsJ.filter(msRun::XMLElement, argument::Activation_Method{<:String})\nmsJ.filter(msRun::XMLElement, argument::Activation_Method{<:AbstractVector})\nmsJ.extracted_chromatogram(filename::String, indices::Vector{Int},method::MethodType)\nmsJ.composite_spectra(filename::String, indices::Vector{Int}, stats::Bool)","category":"page"},{"location":"reference/#msJ.info_mzxml","page":"Reference","title":"msJ.info_mzxml","text":"info_mzxml(filename::String, info::Vector{String}, verbose::Bool=false)\n\nReturns the information content of an mzXML file into a string. Verbosity is controlled by the verbose Boolean variable set by default to false.\n\n\n\n\n\n","category":"function"},{"location":"reference/#msJ.load_mzxml_all","page":"Reference","title":"msJ.load_mzxml_all","text":"load_mzxml_all(filename::String)\n\nLoad an entire an mzxml file, and return the  \n\n\n\n\n\n","category":"function"},{"location":"reference/#msJ.load_mzxml","page":"Reference","title":"msJ.load_mzxml","text":"load_mzxml(filename::String, index::Int\n\nLoad from an mzxml file the scan num that match the input index\n\n\n\n\n\n","category":"function"},{"location":"reference/#msJ.load_mzxml_spectrum","page":"Reference","title":"msJ.load_mzxml_spectrum","text":"load_mzxml_spectrum(c::XMLElement)\n\nFrom an XMLElement, returns the data into an MSscan. \n\n\n\n\n\n","category":"function"},{"location":"reference/#msJ.retention_time-Tuple{LightXML.XMLElement}","page":"Reference","title":"msJ.retention_time","text":"retention_time(msRun::XMLElement)\n\nFrom an XMLE element returns the retention time.\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{LightXML.XMLElement,msJ.Level{#s3} where #s3<:Int64}","page":"Reference","title":"msJ.filter","text":"filter(msRun::XMLElement, argument::Level{<:Int})\n\nSearch for scans matching the argument level and returns a list of index\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{LightXML.XMLElement,msJ.Level{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"Reference","title":"msJ.filter","text":"filter(msRun::XMLElement, argument::Level{<:AbstractVector}\n\nSearch for scans matching the argument levels and returns a list of index\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{LightXML.XMLElement,msJ.Scan{#s3} where #s3<:Int64}","page":"Reference","title":"msJ.filter","text":"filter(msRun::XMLElement, argument::Scan{<:Int})\n\nSearch for scans matching the argument scan num and returns a list of index\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{LightXML.XMLElement,msJ.Scan{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"Reference","title":"msJ.filter","text":"filter(msRun::XMLElement, argument::Scan{<:AbstractVector}\n\nSearch for scans matching the argument scan nums and returns a list of index\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{LightXML.XMLElement,msJ.Polarity{#s3} where #s3<:String}","page":"Reference","title":"msJ.filter","text":"filter(msRun::XMLElement, argument::Polarity{<:String})\n\nSearch for scans matching the argument polarity and returns a list of index\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{LightXML.XMLElement,msJ.Polarity{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"Reference","title":"msJ.filter","text":"filter(msRun::XMLElement, argument::Polarity{<:AbstractVector})\n\nSearch for scans matching the argument polarities and returns a list of index\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{LightXML.XMLElement,msJ.RT{#s3} where #s3<:Real}","page":"Reference","title":"msJ.filter","text":"filter(msRun::XMLElement, argument::RT{<:Real})\n\nSearch for scans matching the argument retention time and returns a list of index\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{LightXML.XMLElement,msJ.RT{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"Reference","title":"msJ.filter","text":"filter(msRun::XMLElement, argument::RT{<:AbstractVector}\n\nSearch for scans matching the argument retention times within the range and returns a list of index\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{LightXML.XMLElement,msJ.RT{#s3} where #s3<:(AbstractArray{#s2,1} where #s2<:(AbstractArray{T,1} where T))}","page":"Reference","title":"msJ.filter","text":"filter(msRun::XMLElement, argument::RT{<:AbstractVector{<:AbstractVector} } )\n\nSearch for scans matching the argument retention times within the ranges and returns a list of index\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{LightXML.XMLElement,msJ.IC{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"Reference","title":"msJ.filter","text":"filter(msRun::XMLElement, argument::IC{<:AbstractVector})\n\nSearch for scans matching for which the total ion current is within the input range returns a list of index\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{LightXML.XMLElement,msJ.Precursor{#s3} where #s3<:Real}","page":"Reference","title":"msJ.filter","text":"filter(msRun::XMLElement, argument::Precursor{<:Real})\n\nSearch for scans matching the argument precursor mz and returns a list of index\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{LightXML.XMLElement,msJ.Precursor{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"Reference","title":"msJ.filter","text":"filter(msRun::XMLElement, argument::Precursor{<:AbstractVector})\n\nSearch for scans matching the argument precusors mz and returns a list of index\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{LightXML.XMLElement,msJ.Activation_Energy{#s3} where #s3<:Real}","page":"Reference","title":"msJ.filter","text":"filter(msRun::XMLElement, argument::Activation_Energy{<:Real})\n\nSearch for scans matching the argument activation energy and returns a list of index\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{LightXML.XMLElement,msJ.Activation_Energy{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"Reference","title":"msJ.filter","text":"filter(msRun::XMLElement, argument::Activation_Energy{<:AbstractVector})\n\nSearch for scans matching the argument activation energies and returns a list of index\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{LightXML.XMLElement,msJ.Activation_Method{#s3} where #s3<:String}","page":"Reference","title":"msJ.filter","text":"filter(msRun::XMLElement, argument::Activation_Method{<:String})\n\nSearch for scans matching the argument activation method and returns a list of index\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{LightXML.XMLElement,msJ.Activation_Method{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"Reference","title":"msJ.filter","text":"filter(msRun::XMLElement, argument::Activation_Method{<:AbstractVector})\n\nSearch for scans matching the argument activation methods and returns a list of index\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.extracted_chromatogram-Tuple{String,Array{Int64,1},msJ.MethodType}","page":"Reference","title":"msJ.extracted_chromatogram","text":"extracted_chromatogram(filename::String, indices::Vector{Int},method::MethodType)\n\nReturns the extracted chromatogram for input file according to the selected method and for set of scan num as input\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.composite_spectra-Tuple{String,Array{Int64,1},Bool}","page":"Reference","title":"msJ.composite_spectra","text":"composite_spectra(filename::String, indices::Vector{Int}, stats::Bool)\n\nReturns the average MSscans for input filename and according to the input scan num. Calculation of variance is controlled by the stats Boolean variable.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Filtering-1","page":"Reference","title":"Filtering","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"msJ.average(scans::Vector{MSscan}, arguments::FilterType...; stats::Bool=true)\nmsJ.chromatogram(scans::Vector{MSscan}, filters::FilterType...; method::MethodType=TIC())\nmsJ.retention_time(scans::Vector{MSscan})\nmsJ.filter(scans::Vector{MSscan}, argument::Scan{<:Int})\nmsJ.filter(scans::Vector{MSscan}, argument::Scan{<:AbstractVector})\nmsJ.filter(scans::Vector{MSscan}, argument::Level{<:Int})\nmsJ.filter(scans::Vector{MSscan}, argument::Level{<:AbstractVector})\nmsJ.filter(scans::Vector{MSscan}, argument::Precursor{<:Real})\nmsJ.filter(scans::Vector{MSscan}, argument::Precursor{<:AbstractVector})\nmsJ.filter(scans::Vector{MSscan}, argument::Activation_Energy{<:Real})\nmsJ.filter(scans::Vector{MSscan}, argument::Activation_Energy{<:AbstractVector})\nmsJ.filter(scans::Vector{MSscan}, argument::Activation_Method{<:String})\nmsJ.filter(scans::Vector{MSscan}, argument::Activation_Method{<:AbstractVector})\nmsJ.filter(scans::Vector{MSscan}, argument::Polarity{<:String})\nmsJ.filter(scans::Vector{MSscan}, argument::Polarity{<:AbstractVector})\nmsJ.filter(scans::Vector{MSscan}, argument::RT{<:Real}) \nmsJ.filter(scans::Vector{MSscan}, argument::RT{<:AbstractVector})\nmsJ.filter(scans::Vector{MSscan}, argument::RT{<:AbstractVector{<:AbstractVector} } )\nmsJ.filter(scans::Vector{MSscan}, argument::IC{<:AbstractVector})\nmsJ.extracted_chromatogram(scans::Vector{MSscan}, indices::Vector{Int},method::MethodType)\nmsJ.composite_spectra(scans::Vector{MSscan}, indices::Vector{Int}, stats::Bool)","category":"page"},{"location":"reference/#msJ.average-Tuple{Array{msJ.MSscan,1},Vararg{msJ.FilterType,N} where N}","page":"Reference","title":"msJ.average","text":"average(scans::Vector{MSscan}, arguments::FilterType...; stats::Bool=true)\n\nReturns the average mass spectrum container (MSscans) along with the sample standard deviation of the intensities with stats=true (default) for all the mass spectra within the Array of mass spectrum container MSscan.. The data may be filtered by level, precursor mass, activation methods, etc, using the arguments msJ.Level(N), msJ.Precursor(mz), msJ.Activation_Method(\"method\"), or any combination of these arguments.\n\nExamples\n\njulia> spectrum = msfilter(\"test.mzxml\")\nmsJ.MSscans([1, 2, 3 ....\njulia> spectrum = msfilter(\"test.mzxml\", msJ.Level(1) )\nmsJ.MSscans([1, 4, 7, 10,\njulia> spectrum = msfilter(\"test.mzxml\", msJ.Precursor(1255.5) )\nmsJ.MSscans([2, 5, 8, 11, ...\njulia> spectrum = msfilter(\"test.mzxml\", msJ.Activation_Method(\"PQD\") )\nmsJ.MSscans([3, 6, 9, 12, 15,\njulia> spectrum = msfilter(\"test.mzxml\", msJ.Activation_Method(\"PQD\"), msJ.Polarity(\"+\"), msJ.RT([10,20]))\nmsJ.MSscans([9, 12, 15, 18], ...\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.chromatogram-Tuple{Array{msJ.MSscan,1},Vararg{msJ.FilterType,N} where N}","page":"Reference","title":"msJ.chromatogram","text":"chromatogram(scans::Vector{MSscan}, filters::FilterType...; method::MethodType=TIC())\n\nReturns the retention time and the total ion current by default for all the mass spectra within the Array of mass spectrum container MSscan. Alternatively, other options may be supplied such as method = msJ.BasePeak, which returs the base peak intensity, method = msJ.∆MZ([500,5]), which returns the ion current for the range mz = 500 ± 5, or method = msJ.MZ([200,1000]) which return the ion current in the range from m/z 200 to m/z 1000.  The data may be filtered by ms level, precursor mass, activation methods, etc, using the arguments msJ.Level(N), msJ.Precursor(mz), msJ.Activation_Method(\"method\")...\n\nExamples\n\njulia> rt, ic = msJ.chromatogram(\"test.mzxml\")\n([0.1384  …  60.4793], [4.74795e6  …  17.4918])\njulia> rt, ic = msJ.chromatogram(\"test.mzxml\", method = msJ.BasePeak() )\n([0.1384  …  60.4793], [102558.0  …  1.23181])\njulia> rt, ic = msJ.chromatogram(\"test.mzxml\", method = msJ.∆MZ([500,5]) )\n([0.1384  …  60.4793], [46036.6  …  14.2529])\njulia> rt, ic = msJ.chromatogram(\"test.mzxml\", method = msJ.MZ([200,1000]))\n([0.1384  …  60.4793], [4.74795e6  …  17.4918])\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.retention_time-Tuple{Array{msJ.MSscan,1}}","page":"Reference","title":"msJ.retention_time","text":"retention_time(scans::Vector{MSscan})\n\nReturns an array composed of the retention times of the individual mass spectra. \n\nExamples\n\njulia> msJ.retention_time(\"scans\")\n51-element Array{Float64,1}:\n  0.1384\n  0.7307\n  2.1379\n....\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{Array{msJ.MSscan,1},msJ.Scan{#s3} where #s3<:Int64}","page":"Reference","title":"msJ.filter","text":"filter(scans::Vector{MSscan}, argument::Scan{<:Int})\n\nSearch for scans matching the argument scan num and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{Array{msJ.MSscan,1},msJ.Scan{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"Reference","title":"msJ.filter","text":"filter(scans::Vector{MSscan}, argument::Scan{<:AbstractVector})\n\nSearch for scans matching the argument scan nums and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{Array{msJ.MSscan,1},msJ.Level{#s3} where #s3<:Int64}","page":"Reference","title":"msJ.filter","text":"filter(scans::Vector{MSscan}, argument::Level{<:Int})\n\nSearch for scans matching the argument MS level and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{Array{msJ.MSscan,1},msJ.Level{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"Reference","title":"msJ.filter","text":"filter(scans::Vector{MSscan}, argument::Level{<:AbstractVector})\n\nSearch for scans matching the argument MS levels and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{Array{msJ.MSscan,1},msJ.Precursor{#s3} where #s3<:Real}","page":"Reference","title":"msJ.filter","text":"filter(scans::Vector{MSscan}, argument::Precursor{<:Real})\n\nSearch for scans matching the argument precursor mz and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{Array{msJ.MSscan,1},msJ.Precursor{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"Reference","title":"msJ.filter","text":"filter(scans::Vector{MSscan}, argument::Precursor{<:AbstractVector})\n\nSearch for scans matching the argument precursors mz and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{Array{msJ.MSscan,1},msJ.Activation_Energy{#s3} where #s3<:Real}","page":"Reference","title":"msJ.filter","text":"filter(scans::Vector{MSscan}, argument::Activation_Energy{<:Real})\n\nSearch for scans matching the argument activation energy and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{Array{msJ.MSscan,1},msJ.Activation_Energy{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"Reference","title":"msJ.filter","text":"filter(scans::Vector{MSscan}, argument::Activation_Energy{<:AbstractVector})\n\nSearch for scans matching the argument activation energies and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{Array{msJ.MSscan,1},msJ.Activation_Method{#s3} where #s3<:String}","page":"Reference","title":"msJ.filter","text":"filter(scans::Vector{MSscan}, argument::Activation_Method{<:String})\n\nSearch for scans matching the argument activation method and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{Array{msJ.MSscan,1},msJ.Activation_Method{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"Reference","title":"msJ.filter","text":"filter(scans::Vector{MSscan}, argument::Activation_Method{<:AbstractVector})\n\nSearch for scans matching the argument activation methods and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{Array{msJ.MSscan,1},msJ.Polarity{#s3} where #s3<:String}","page":"Reference","title":"msJ.filter","text":"filter(scans::Vector{MSscan}, argument::Polarity{<:String})\n\nSearch for scans matching the argument polarity and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{Array{msJ.MSscan,1},msJ.Polarity{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"Reference","title":"msJ.filter","text":"filter(scans::Vector{MSscan}, argument::Polarity{<:AbstractVector})\n\nSearch for scans matching the argument polarities and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{Array{msJ.MSscan,1},msJ.RT{#s3} where #s3<:Real}","page":"Reference","title":"msJ.filter","text":"filter(scans::Vector{MSscan}, argument::RT{<:Real})\n\nSearch for scans matching the argument retention time and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{Array{msJ.MSscan,1},msJ.RT{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"Reference","title":"msJ.filter","text":"filter(scans::Vector{MSscan}, argument::RT{<:AbstractVector})\n\nSearch for scans matching the argument retention time in the specified range and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{Array{msJ.MSscan,1},msJ.RT{#s3} where #s3<:(AbstractArray{#s2,1} where #s2<:(AbstractArray{T,1} where T))}","page":"Reference","title":"msJ.filter","text":"filter(scans::Vector{MSscan}, argument::RT{<:AbstractVector{<:AbstractVector} } )\n\nSearch for scans matching the argument retention time in the specified ranges and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.filter-Tuple{Array{msJ.MSscan,1},msJ.IC{#s3} where #s3<:(AbstractArray{T,1} where T)}","page":"Reference","title":"msJ.filter","text":"filter(scans::Vector{MSscan}, argument::IC{<:AbstractVector})\n\nSearch for scans matching the argument total ion current within the specified ranges and returns a list of the corresponding indexes\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.extracted_chromatogram-Tuple{Array{msJ.MSscan,1},Array{Int64,1},msJ.MethodType}","page":"Reference","title":"msJ.extracted_chromatogram","text":"extracted_chromatogram(scans::Vector{MSscan}, indices::Vector{Int},method::MethodType)\n\nReturns the extracted chromatogram for input Array of MSscan according to the selected method and for set of scan num as input\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.composite_spectra-Tuple{Array{msJ.MSscan,1},Array{Int64,1},Bool}","page":"Reference","title":"msJ.composite_spectra","text":"composite_spectra(scans::Vector{MSscan}, indices::Vector{Int}, stats::Bool)\n\nReturns the average MSscans for input Array of MSscan and according to the input scan num. Calculation of variance is controlled by the stats Boolean variable.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Extracting-subsets-1","page":"Reference","title":"Extracting subsets","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"msJ.extract(filename::String, arguments::FilterType...)\nmsJ.extract(scans::Vector{MSscan}, arguments::FilterType...)\nmsJ.build_subset(filename::String, indices::Vector{Int})\nmsJ.build_subset(scans::Vector{MSscan}, indices::Vector{Int})","category":"page"},{"location":"reference/#msJ.extract-Tuple{String,Vararg{msJ.FilterType,N} where N}","page":"Reference","title":"msJ.extract","text":"extract(filename::String, arguments::FilterType...)\n\nSearch for scans matching the argument MS level and returns an array of matching MSscans otherwise returns an ErrorException: \"No matching spectra found.\"\n\nExamples\n\njulia> sub_set = extract(\"test.mzxml\")\n6-element Array{msJ.MSscan,1}:\n msJ.MSscan(1, 0.1384, 5.08195e6, [140.083, 140.167, 140.25, 140.333, 140.417, 140.5, 140.583, 140.667, 140.75, 140.833  …  1999.25, 1999.33, 1999.42, ....\njulia> sub_set = extract(\"test.mzxml\", msJ.Level(2) )      # extract MS/MS spectra\nmsJ.MSscan(2, 0.7307, 9727.2, [345.083, 345.167, 345.25, 345.333, 345.417, 345.5, 345.583, 345.667, 345.75, 345.833  …  1999.25, 1999.33, 1999.42, 1999.5, 1999.58 ....\n msJ.MSscan(5, 4.3442, 12203.5, [345.083, 345.167, 345.25, 345.333, 345.417, 345.5, 345.583, 345.667, 345.75, 345.833  …  1999.25, 1999.33, 1999.42, 1999.5, 1999.58, ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.extract-Tuple{Array{msJ.MSscan,1},Vararg{msJ.FilterType,N} where N}","page":"Reference","title":"msJ.extract","text":"extract(scans::Vector{MSscan}, arguments::FilterType...)\n\nSearch for scans matching the argument MS level and returns an array of matching MSscans otherwise returns an ErrorException: \"No matching spectra found.\"\n\nExamples\n\njulia> scans = load(\"test.mzxml\")                          # load mass spectra\n6-element Array{msJ.MSscan,1}:\n msJ.MSscan(1, 0.1384, 5.08195e6, [140.083, 140.167, 140.25, 140.333, 140.417, 140.5, 140.583, 140.667, 140.75, 140.833  …  1999.25, 1999.33, 1999.42, ...\njulia> sub_set = extract(scans)                            # extract a sub_set without conditions returns the original data\n6-element Array{msJ.MSscan,1}:\n msJ.MSscan(1, 0.1384, 5.08195e6, [140.083, 140.167, 140.25, 140.333, 140.417, 140.5, 140.583, 140.667, 140.75, 140.833  …  1999.25, 1999.33, 1999.42, ....\njulia> sub_set = extract(scans, msJ.Level(2) )      # extract MS/MS spectra\nmsJ.MSscan(2, 0.7307, 9727.2, [345.083, 345.167, 345.25, 345.333, 345.417, 345.5, 345.583, 345.667, 345.75, 345.833  …  1999.25, 1999.33, 1999.42, 1999.5, 1999.58 ....\n msJ.MSscan(5, 4.3442, 12203.5, [345.083, 345.167, 345.25, 345.333, 345.417, 345.5, 345.583, 345.667, 345.75, 345.833  …  1999.25, 1999.33, 1999.42, 1999.5, 1999.58, ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.build_subset-Tuple{String,Array{Int64,1}}","page":"Reference","title":"msJ.build_subset","text":"build_subset(filename::String, indices::Vector{Int})\n\nReturns a Vector of MSscan from the input file according to the scan num (indices).\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.build_subset-Tuple{Array{msJ.MSscan,1},Array{Int64,1}}","page":"Reference","title":"msJ.build_subset","text":"build_subset(scans::Vector{MSscan}, indices::Vector{Int})\n\nReturns a Vector of MSscan according to the input scan num.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Process-1","page":"Reference","title":"Process","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#Mass-spectrum-1","page":"Reference","title":"Mass spectrum","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"msJ.smooth(scan::MScontainer; method::MethodType=SG(5, 9, 0))\nmsJ.savitzky_golay_filtering(scan::MScontainer, order::Int, window::Int, deriv::Int)\nmsJ.centroid(scan::MScontainer; method::MethodType=SNRA(1., 100) )\nmsJ.centroid(scans::Vector{MSscan}; method::MethodType=SNRA(1., 100) \nmsJ.snra(scan::MScontainer, thres::Real, region::Int)\nmsJ.tbpd(scan::MScontainer, model::Function,  ∆mz::Real, thres::Real)\nmsJ.gauss(x::Float64, p::Vector{Float64})\nmsJ.lorentz(x::Float64, p::Vector{Float64})\nmsJ.voigt(x::Float64, p::Vector{Float64})\nmsJ.tbpd(scan::MScontainer, shape::Symbol,  R::Real, thres::Real)\nmsJ.baseline_correction(scan::MScontainer; method::MethodType=TopHat(100) )\nmsJ.baseline_correction(scans::Vector{MSscan}; method::MethodType=TopHat(100))\nmsJ.tophat_filter(scan::MScontainer, region::Int )\nmsJ.tophat_filter(scans::Vector{MSscan}, region::Int )\nmsJ.loess(scans::Vector{MSscan}, iter::Int )\nmsJ.loess(scan::MScontainer, iter::Int )\nmsJ.ipsa(scan::MScontainer, width::Real, maxiter::Int)\nmsJ.ipsa(scans::Vector{MSscan}, width::Real, maxiter::Int)","category":"page"},{"location":"reference/#msJ.smooth-Tuple{msJ.MScontainer}","page":"Reference","title":"msJ.smooth","text":"smooth(scan::MScontainer; method::MethodType=SG(5, 9))\n\nSmooth the intensity of the input data and returns a similar structure.\n\nExamples\n\njulia> smoothed_data = msJ.smooth(scans)\nmsJ.MSscans(1, 0.1384, 5.08195e6, [140.083, 140.167, 140.25, 140.333, 140.417, 140.5, 140.583, 140.667, 140.75, 140.833  …  1999.25, 1999.33, 1999.42, ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.savitzky_golay_filtering-Tuple{msJ.MScontainer,Int64,Int64,Int64}","page":"Reference","title":"msJ.savitzky_golay_filtering","text":"savitzky_golay_filtering(scan::msJ.MScontainer, order::Int, window::Int, deriv::Int)\n\nSavinsky and Golay filtering of mz and int data within the MSscan(s) container.\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.centroid-Tuple{msJ.MScontainer}","page":"Reference","title":"msJ.centroid","text":"centroid(scan::MScontainer; method::MethodType=MethodType=SNRA(1., 100) )\n\nPeak picking algorithm taking a MSscan or MSscans object as input and returning an object of the same type containing the detected peaks.  Available algorithm are : Signal to Noise Ratio (SNR) and Template Based Peak Detection (TBPD). Default method is Signal to Noise Ratio Analysis (SNRA), with default threshold = 1.0 and region = 100.\n\nExamples\n\njulia> centroid(scans)\nMSscans(1, 0.1384, 5.08195e6, [140.083, 140.167, 140.25, 140.333, 140.417, 140.5, 140.583, 140.667, 140.75, 140.833  …  1999.25, 1999.33, 1999.42, ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#Chromatogram-1","page":"Reference","title":"Chromatogram","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"No functions yet. To be added.","category":"page"},{"location":"reference/#Plots-1","page":"Reference","title":"Plots","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [msJ.plots]\n","category":"page"},{"location":"reference/#msJ.plots","page":"Reference","title":"msJ.plots","text":"Plotting module for MScontainer data type (MSscan, MSscans and Chromatogram).\n\njulia> plot(scans[1])\njulia> plot(chr)\n\n\n\n\n\n","category":"module"},{"location":"reference/#RecipesBase.apply_recipe-Tuple{Dict{Symbol,Any},msJ.Chromatogram}","page":"Reference","title":"RecipesBase.apply_recipe","text":"h(cr::msJ.Chromatogram; method = :relative)\n\nAllows plotting directly chromatograms. The defaults relative intensity plotting may be changed by setting method = :absolute.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RecipesBase.apply_recipe-Tuple{Dict{Symbol,Any},msJ.MSscans}","page":"Reference","title":"RecipesBase.apply_recipe","text":"g(ms::msJ.MSscans; method = :relative)\n\nAllows plotting directly mass spectra MSscans. The defaults relative intensity plotting may be changed by setting method = :absolute.\n\n\n\n\n\n","category":"method"},{"location":"reference/#RecipesBase.apply_recipe-Tuple{Dict{Symbol,Any},msJ.MSscan}","page":"Reference","title":"RecipesBase.apply_recipe","text":"f(ms::MSscan; method = :relative)\n\nAllows plotting directly mass spectra MSscan. The defaults relative intensity plotting may be changed by setting method = :absolute.\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.plots.normalisation-Tuple{msJ.Chromatogram}","page":"Reference","title":"msJ.plots.normalisation","text":"normalisation(cr::msJ.Chromatogram)\n\nNormalization function for plotting chromatograms in raltive intensity.\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.plots.normalisation-Tuple{msJ.MScontainer}","page":"Reference","title":"msJ.plots.normalisation","text":"normalisation(ms::msJ.MScontainer)\n\nNormalization function for plotting mass spectra in relative intensity.\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.plots.scaling-Tuple{msJ.Chromatogram}","page":"Reference","title":"msJ.plots.scaling","text":"scaling(cr::msJ.Chromatogram)\n\nScaling function to display retention times of chromatograms in minutes instead of seconds.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Utilities-1","page":"Reference","title":"Utilities","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#Base-overloaded-1","page":"Reference","title":"Base overloaded","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"+(a::MScontainer, b::MScontainer)\n-(a::MScontainer, b::MScontainer)\n/(a::MSscan, N::Real)\n/(a::MSscans, N::Real)\n*(a::MSscan, N::Real)\n*(a::MSscans, N::Real)\n*(N::Real, a::MScontainer)\n*(a::MScontainer, b::MScontainer)","category":"page"},{"location":"reference/#Base.:+-Tuple{msJ.MScontainer,msJ.MScontainer}","page":"Reference","title":"Base.:+","text":"+(a::MScontainer, b::MScontainer)\n\nAddition of mass spectra elementwise.\n\njulia> scans[1] - scans[2]\nmsJ.MSscans([1, 2], [0.1384, 0.7307]\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:--Tuple{msJ.MScontainer,msJ.MScontainer}","page":"Reference","title":"Base.:-","text":"-(a::MScontainer, b::MScontainer)\n\nSubstraction of mass spectra elementwise. Negative scan num refers the 'b' MScontainer\n\njulia> a - b\nmsJ.MSscans([1, 4], [0.1384, 3.7578, -0.1384, -3.7578]...\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:/-Tuple{msJ.MSscan,Real}","page":"Reference","title":"Base.:/","text":"/(a::MSscan, N::Real)\n\nDivide the intensity and the tic data of a MSscan by a number\n\njulia> scans[1] / 1.0e2\nmsJ.MSscan(1, 0.1384, 50819.5, [140. ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:/-Tuple{msJ.MSscans,Real}","page":"Reference","title":"Base.:/","text":"/(a::MSscans, N::Real)\n\nDivide in the intenisty, tic and variance of a MSscans by a number\n\njulia> a / 1.0e2\nmsJ.MSscans(1, 0.1384, 50819.5, [140. ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:*-Tuple{msJ.MSscan,Real}","page":"Reference","title":"Base.:*","text":"*(a::MSscan, N::Real)\n\nMultiply the intensity and the tic data of a MSscan by a number\n\njulia> scans[1] * 1.0e2\nmsJ.MSscan(1, 0.1384, 50819.5, [140. ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:*-Tuple{msJ.MSscans,Real}","page":"Reference","title":"Base.:*","text":"*(a::MSscans, N::Real)\n\nMultiply in the intenisty, tic and variance of a MSscans by a number\n\njulia> a * 1.0e2\nmsJ.MSscans(1, 0.1384, 50819.5, [140. ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:*-Tuple{Real,msJ.MScontainer}","page":"Reference","title":"Base.:*","text":"*(N::Real, a::MScontainer)\n\nCommutation of multiplication of number with MSscontainer\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.:*-Tuple{msJ.MScontainer,msJ.MScontainer}","page":"Reference","title":"Base.:*","text":"*(a::MScontainer, b::MScontainer)\n\nMultiplication of mass spectra elementwise.\n\njulia> a * b\nmsJ.MSscans([2, 5], [0.7307, 4.344\n\n\n\n\n\n","category":"method"},{"location":"reference/#Utility-function-1","page":"Reference","title":"Utility function","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"msJ.avg(a::MScontainer, b::MScontainer)\nmsJ.add_ion_current(x::Vector{Float64}, y::Vector{Float64}, a::Float64, b::Float64)\nmsJ.num2pnt(x::Vector{Float64}, val::Real)\nsavitzky_golay(int::AbstractArray, order::Int, window::Int, deriv::Int)\nextremefilt(input::AbstractArray, minmax::Function, region::Int)\nmorpholaplace(input::AbstractArray, region::Int)\nmorphogradient(input::AbstractArray, region::Int)\ntophat(input::AbstractArray, region::Int)\nbottomhat(input::AbstractArray, region::Int) \nopening(input::AbstractArray, region::Int)\nclosing(input::AbstractArray, region::Int)\nerosion(input::AbstractArray, region::Int)\ndilatation(input::AbstractArray, region::Int)","category":"page"},{"location":"reference/#msJ.avg-Tuple{msJ.MScontainer,msJ.MScontainer}","page":"Reference","title":"msJ.avg","text":"avg(a::MScontainer, b::MScontainer)\n\nReturns the average of the input mass spectra and compute the variance using an incremental Welford algorithm.\n\njulia> msJ.avg(scans[1], scans[4])\nmsJ.MSscans([1, 4], [0.1384, 3.7578], ....\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.add_ion_current-Tuple{Array{Float64,1},Array{Float64,1},Float64,Float64}","page":"Reference","title":"msJ.add_ion_current","text":"add_ion_current(x::AbstractArray, y::AbstractArray, a::Real, b::Real)\n\nReturns sum the ion current (int) within the m/z range defined by the a and b input values.\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.num2pnt-Tuple{Array{Float64,1},Real}","page":"Reference","title":"msJ.num2pnt","text":"num2pnt(x::AbstractArray, val::Real)\n\nGeneral purpose utility function used to retrieve the index of an array for which the value is closest to the input.\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.savitzky_golay-Tuple{AbstractArray,Int64,Int64,Int64}","page":"Reference","title":"msJ.savitzky_golay","text":"savitzky_golay(int::Vector{Float64}, order::Int, window::Int, deriv::Int)\n\nSavinsky and Golay filter removes high frequency noise from data. Parameters:     int::AbstractArray     order::Int   order of the polynomial     window::Int  length of the window, has to be an odd number     deriv::Int   the order of the derivative to be computed. Default = 0 leads to smoothing only.\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.extremefilt-Tuple{AbstractArray,Function,Int64}","page":"Reference","title":"msJ.extremefilt","text":"extremefilt(input::AbstractArray, minmax::Function, region::Int)\n\nReturn the erosion or the dilation of the input over the region, which the size of the structuring element.\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.morpholaplace-Tuple{AbstractArray,Int64}","page":"Reference","title":"msJ.morpholaplace","text":"morpholaplace(input::AbstractArray, region::Int)\n\nPerfoms morphological Laplacian of the input array, as defined by the addition of the dilatation and the erosion of the input array.\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.morphogradient-Tuple{AbstractArray,Int64}","page":"Reference","title":"msJ.morphogradient","text":"morphogradient(input::AbstractArray, region::Int)\n\nPerfoms morphological Gradient of the input array, defined by the difference between the dilatation and the erosion of the input array.\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.tophat-Tuple{AbstractArray,Int64}","page":"Reference","title":"msJ.tophat","text":"tophat(input::AbstractArray, region::Int)\n\nPerforms the Top Hat of the input Array, defined by the difference between the input and its morphological opening.\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.bottomhat-Tuple{AbstractArray,Int64}","page":"Reference","title":"msJ.bottomhat","text":"bottomhat(input::AbstractArray, region::Int)\n\nPerforms the Bottom Hat of the input Array, defined by the difference between the morphological closing of the input and the input.\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.opening-Tuple{AbstractArray,Int64}","page":"Reference","title":"msJ.opening","text":"opening(input::AbstractArray, region::Int)\n\nPerforms the morphological opening of the input Array, which is the dilatation of the erosion of the input\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.closing-Tuple{AbstractArray,Int64}","page":"Reference","title":"msJ.closing","text":"closing(input::AbstractArray, region::Int\n\nPerforms the morphological closing of the input Array, which is defined as the erosion of the dilatation of the input.\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.erosion-Tuple{AbstractArray,Int64}","page":"Reference","title":"msJ.erosion","text":"erosion(input::AbstractArray, region::Int)\n\nPerforms the morphological erosion of the input, which is the minimum-filtering over the structuring element region.\n\n\n\n\n\n","category":"method"},{"location":"reference/#msJ.dilatation-Tuple{AbstractArray,Int64}","page":"Reference","title":"msJ.dilatation","text":"dilatation(input::AbstractArray, region::Int)\n\nPerforms the morphological dilatation of the input, which is the maximum-filtering over the structuring element region\n\n\n\n\n\n","category":"method"},{"location":"#Home-1","page":"Home","title":"Home","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"msJ.jl is a package for loading, processing and plotting mass spectrometry data. It provides a range of functionalities such as:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Getting information on the file\nReading a file\nAveraging mass spectra based on various criteria that may be combined\nGetting chromatogram\nProcessing the data","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The tutorial page shows examples how to use this package and provides a general guide to it. The manual page explains the structure of the package and the reference page gives a full documentation for each type and function.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"There are two ways of installing the package.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> using Pkg ;\njulia> Pkg.add(PackageSpec(url=\"https://github.com/ajgiuliani/msJ.jl\"))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"or","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> ]\n(v1.1) pkg>  add https://github.com/ajgiuliani/msJ.jl","category":"page"},{"location":"#Supported-file-format-1","page":"Home","title":"Supported file format","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"mzXML","category":"page"},{"location":"tutorial/#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Plots","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The msJ package intends to provide an access to the common open source mass spectrometry file format using Julia.","category":"page"},{"location":"tutorial/#The-Julia-language-1","page":"Tutorial","title":"The Julia language","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Julia is an open source programming language designed for scientific and technical computing. This section will give a very brief introduction to the Julia language. ","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"!!! note: see also","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The [Julia](https://julialang.org/) language home page  \nIntroduction to Julia [Wikibook](https://en.wikibooks.org/wiki/Introducing_Julia)","category":"page"},{"location":"tutorial/#Installation-1","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Julia binaries are available for various platforms and can be downloaded here.  Plateform specific instructions may be found here.","category":"page"},{"location":"tutorial/#Executing-Julia-code-1","page":"Tutorial","title":"Executing Julia code","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Julia code can be executed interactively using the REPL as follow:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"println(\"Hello\")","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The println(\"Hello\") line can be put in a file, such as hello.jl and executed as a script, which will produce the same output.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"$ julia hello.jl","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"You can also put #!/usr/local/bin/julia in the first line of the hello.jl file, make it executable (chmod +x hello.jl) and execute it like any other executable.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Finally, Julia scripts can be executed within Jupyter Notebooks, see the dedicated section Jupyter notebooks.","category":"page"},{"location":"tutorial/#Types-1","page":"Tutorial","title":"Types","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Julia is a strongly typed language. Julia has the following predefined types (from the julia wikibook): (Image: )","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In Julia types are organized in a hierarchy with a tree structure. The root of the tree is the Any type.  The Number type is a direct child of Any and possesses two subtypes: Complex and Real. The Real type has three types: Integer, AbstractFloat, Irrational and Rational.","category":"page"},{"location":"tutorial/#Creating-vectors-and-matrices-1","page":"Tutorial","title":"Creating vectors and matrices","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"A vector is created as follow","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"A = [1, 2, 3]                  # vector\nA = range(1, 10, step = 2)   # linearly spaced\nA = range(1, 10, length = 5) # linearly spaced\nA = rand(10)                 # random with 10 elements\nj = 2; k = 2; n = 10;\nA = j:k:n                    # from j to n with step size k","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"and similarly for matrices","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"A = [1 2; 3 4]               # matrix\nA = rand(2, 2)               # random 2x2 matrix","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Vector and matrices can be manipulated as follow:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"transpose(A)                 # Return the transpose of A\nA[:]                         # Flatten matrix A (convert matrix to vector)\nA[2,2]                       # Accessing element at row 2 and colomun 2\nA[1:4, :]                    # Accessing specific rows 1 to 4","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Vector and matrix may be preallocated like this:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"A = rand(5)                  # a vector / matrix\nB = similar(A)               # an emply vector / matrix similar to A","category":"page"},{"location":"tutorial/#Operations-1","page":"Tutorial","title":"Operations","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The following present a few example of operations:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"julia> dot(A,B)                     # dot product between A and B \njulia> A .* B                       # Element wise multiplication\njulia> A * B                        # Matrix multiplcation\njulia> norm(A)                      # Euclidian norm\njulia> sum(A, dims = 1)             # sum over each column\njulia> sum(A, dims = 2)             # sum over each rows","category":"page"},{"location":"tutorial/#Loops-1","page":"Tutorial","title":"Loops","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"A loop in Julia can be done like this:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"julia> for i in 1:N\njulia>   #do something\njulia> end","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"While loops my be achiçved like this:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"julia> while i <= N\njulia>   #do something\njulia> end","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"and if / else flow like this:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"julia> if i < N\njulia>   #do something\njulia> else \njulia>   #do something else\njulia> end","category":"page"},{"location":"tutorial/#Functions-and-methods-1","page":"Tutorial","title":"Functions and methods","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"A function is defined like this:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"julia> function f(x)\njulia>   return x^2\njulia> end","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"which can be simplified as:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"julia> f(x) = x^2","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Broadcasting a function over a collection or an Array is achieved like this:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"julia> f(x) = x^2\njulia> x = 1:10\njulia> f.(x)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In Julia, functions that modify their arguments are named !, such as:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"julia> function f!(out, x)\njulia>   out = x.^2\njulia> end\njulia> x = rand(10)\njulia> y = similar(x)\njulia> f!(y, x)","category":"page"},{"location":"tutorial/#Importing-and-using-Packages-1","page":"Tutorial","title":"Importing and using Packages","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Julia code is organized into files, modules and packages. A file using the .jl extension contains julia code. Related functions and variable may be gathered in modules.  One or more modules may be organized into packages. Packages may be installed like hits:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"julia> using A_package","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Or like this if it is not installed:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"julia> using Pkg                      # using the Package manager package\njulia> Pkg.add(\"A_package\")\njulia> using A_package","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Now every public function from A_package is available directly. Private functions have to be called like this: ","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"julia> A_package.a_private_function()        # Calling private functions\njulia> a_public_function()                   # Calling a public function","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The same is true for the variables defined in the packages.","category":"page"},{"location":"tutorial/#Jupyter-notebooks-1","page":"Tutorial","title":"Jupyter notebooks","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Jupyter notebooks are web based documents that may contains both codes, figures and other textual elements (such as equations, links, ...).  Jupyter notebook may be installed easily using Julia:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"julia> using Pkg\njulia> Pkg.add(\"IJulia\")","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"When IJulia is installed, then a notebook may be launch like this:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"julia> using IJulia\njulia> notebook()","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The notebook() function should launch a web browser from which a new notebook  may be started. On each entry of the notebook code, Markdown or text may be inserted. Each line of code may be executed and will eventually return a result. In the following, the tutorials are given in Jupyter notebook form.","category":"page"},{"location":"tutorial/#Example-1:-Loading-and-plotting-mass-spectrometry-data-1","page":"Tutorial","title":"Example 1: Loading and plotting mass spectrometry data","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This tutorial shows how to use how to import data and how to plot mass spectra. Notebook","category":"page"},{"location":"tutorial/#Example-2:-Filtering-and-averaging-1","page":"Tutorial","title":"Example 2: Filtering and averaging","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"This notebook shows how to filter and average data. Notebook","category":"page"},{"location":"tutorial/#Example-3:-Data-treatment-for-UV-spectroscopy-1","page":"Tutorial","title":"Example 3: Data treatment for UV spectroscopy","text":"","category":"section"}]
}
